从传输数据角度分析数据流：

UI: UI不需要关心具体请求类型，只需要指定命令类型type和命令字cmd，自动处理成对应的请求DTO，然后调用DTO.ToJson将请求转换为json格式字符串

```C++
// 伪代码  DTO基类：IDTO  工厂类：DTOFactory  DTO子类：FileRequestDTO...
#include "DTOFactory"
#include "IDTO"

// MessageType 消息类型 请求/响应/日志...  CommandType 请求类型 文件操作/进程操作/网络操作...
// Command 命令字 添加文件创建监控...

void CSecurityGuardUIDlg::OnBnClickedProcessFileMoniter()
{
    // 一个按键固定一个CMD请求
    MessageType msgType = MESSAGE_REQUEST;
    Command cmd = COMMAND_FILECREATEHOOK;
    CommandType type = TYPE_FILE;
    // 获取用户输入数据 GetWindowsText  pid
    CString cstrText;
    m_editPid.GetWindowText(cstrText);
    int pid = ...; // 转换为int
    // 创建DTO  使用了Param类（具体实现查看代码），没有办法再按类聚合了，只能一个命令字一个DTO了
    // 这会导致具体类里会有大量冗余代码
    IDTO* dto = DTOFactory::Create(msgType, type, cmd);
    // 这里为了解耦处理了两次，会增加很多性能开销，待考虑
    dto.param.Set("request_message_id", GenerateMessageId());
    dto.param.Set("request_timestamp", GetTimeStamp());
    dto.param.Set("request_request_id", GenerateRequestId);
    dto.param.Set("request_process_id", pid);
	...;
    std::string strJson = dto.ToJson();
 	// 组装消息头 命令类型type、cmd放到消息头里
    Header header = GenerateHeader(type, cmd);
    // 发送消息头
    send(header);
    // 发送请求
    send(strJson);
}
```

Service: Service也不需要关心具体请求类型，将json字符串转换为DTO，然后找到type、cmd，进行分发

```c++
// 伪代码  DTO基类：IDTO  工厂类：DTOFactory  DTO子类：FileRequestDTO...
#include "DTOFactory"
#include "IDTO"

void Service::Recive(Header header)
{
    // 从header获得cmd、cmdtype、messagetype
    cmd = header.cmd;
    type = header.type;
    messageType = header.msgType;
    ...;
}

void Service::Recive(const std::string& strJson)
{
	// 创建DTO
    IDTO* dto = DTOFactory::Create(msgType, type, cmd);
    // 解析json到dto
    dto.FromJson();
    // 根据cmd分发请求  这里的分发是加载dll时，dll先注册了自己支持的处理类型 根据类型找到对应的处理函数
    Dispatch(type, cmd，dto.param);
}
```

ProtectionModule: 根据type找到对应类，再根据cmd找到对应的处理函数，将param作为入参传入，其他内容由内部处理，业务层不关心

```c++
// 伪代码  DTO基类：IDTO  工厂类：DTOFactory  DTO子类：FileRequestDTO...
ProtectionModule::Handle(CommandType type, uint32_t cmd, Param param)
{
	switch (type)
    {
        case TYPE_FILE:
            FileHandler::Handle(cmd, param)
            break;
        ...;
    }
}

// 文件处理类
FileHandler::Handle(uint32_t cmd, Param param)
{
    switch (cmd)
    {
        case COMMAND_FILECREATEHOOK:
            handleFileCreateHook(param);
            break;
        ...;
    }
}

// 具体处理
FileHandler::handleFileCreateHook(Param param)
{
    // 解析参数
    ...;
    // 执行HOOK
    ...;
}
```

