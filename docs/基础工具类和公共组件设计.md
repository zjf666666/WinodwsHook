# 基础工具类和公共组件设计说明

## 1. 基础工具类的功能与用途

基础工具类是整个Windows安全防护系统的底层支撑，提供通用的、可复用的功能模块：

### 核心功能模块：

#### 字符串处理工具类 (StringUtils)
- **功能**：
  - 宽字符与多字节字符转换
  - 字符串格式化、分割、替换
  - 路径规范化处理
- **用途**：统一字符串处理标准，避免编码问题

#### 文件操作工具类 (FileUtils)
- **功能**：
  - 文件读写、复制、移动、删除
  - 目录遍历和创建
  - 文件属性获取和修改
  - 临时文件管理
- **用途**：封装Windows文件API，提供安全的文件操作接口

#### 注册表工具类 (RegistryUtils)
- **功能**：
  - 注册表键值的读取、写入、删除
  - 注册表权限检查
  - 注册表监控
- **用途**：统一注册表操作，支持配置管理和系统监控

#### 进程工具类 (ProcessUtils)
- **功能**：
  - 进程枚举和信息获取
  - 进程创建、终止、挂起
  - 进程权限提升
  - 模块枚举和信息获取
- **用途**：支持进程监控和管理功能

#### 系统信息工具类 (SystemUtils)
- **功能**：
  - 系统版本、架构信息获取
  - 硬件信息收集
  - 系统性能监控
- **用途**：提供系统环境检测和适配能力

#### 加密工具类 (CryptoUtils)
- **功能**：
  - 哈希计算（MD5、SHA256等）
  - 对称加密/解密（AES）
  - 数字签名验证
- **用途**：保护敏感数据和验证文件完整性

## 2. 公共组件的功能与用途

公共组件是系统级的服务模块，为各个子系统提供统一的基础服务：

### 核心组件模块：

#### 日志组件 (Logger)
- **功能**：
  - 多级别日志记录（Debug、Info、Warning、Error）
  - 日志文件轮转和压缩
  - 实时日志查看
  - 性能日志统计
- **用途**：统一日志管理，支持问题诊断和性能分析

#### 配置管理组件 (ConfigManager)
- **功能**：
  - 配置文件读写和解析
  - 配置热更新
  - 配置验证和默认值处理
  - 配置加密存储
- **用途**：集中管理系统配置，支持动态配置更新

#### 事件总线组件 (EventBus)
- **功能**：
  - 模块间消息传递
  - 事件订阅和发布
  - 异步事件处理
  - 事件优先级管理
- **用途**：解耦模块间依赖，实现松耦合架构

#### 线程池组件 (ThreadPool)
- **功能**：
  - 工作线程管理
  - 任务队列调度
  - 线程优先级控制
  - 资源限制和监控
- **用途**：优化系统性能，避免频繁创建销毁线程

#### 内存管理组件 (MemoryManager)
- **功能**：
  - 内存池管理
  - 内存泄漏检测
  - 内存使用统计
  - 智能指针封装
- **用途**：提高内存使用效率，防止内存泄漏

#### 通信组件 (IPC)
- **功能**：
  - 进程间通信（命名管道、共享内存）
  - 网络通信封装
  - 消息序列化/反序列化
  - 通信加密和认证
- **用途**：支持模块间和进程间的安全通信

## 3. 设计模式及原因

### 基础工具类采用的设计模式：

#### 单例模式 (Singleton)
- **应用场景**：日志组件、配置管理组件
- **原因**：确保全局唯一实例，避免资源冲突，提供全局访问点

#### 工厂模式 (Factory)
- **应用场景**：加密算法创建、文件操作对象创建
- **原因**：封装对象创建逻辑，支持运行时选择具体实现

#### 策略模式 (Strategy)
- **应用场景**：不同加密算法、不同文件操作策略
- **原因**：支持算法动态切换，提高代码可扩展性

### 公共组件采用的设计模式：

#### 观察者模式 (Observer)
- **应用场景**：事件总线、配置变更通知
- **原因**：实现松耦合的事件通知机制，支持一对多依赖关系

#### 命令模式 (Command)
- **应用场景**：线程池任务调度、操作撤销
- **原因**：将请求封装为对象，支持队列、日志和撤销操作

#### 适配器模式 (Adapter)
- **应用场景**：不同版本Windows API适配、第三方库集成
- **原因**：统一接口标准，屏蔽底层差异

#### 装饰器模式 (Decorator)
- **应用场景**：日志功能增强、加密传输
- **原因**：动态添加功能，避免类爆炸问题

#### 模板方法模式 (Template Method)
- **应用场景**：文件操作流程、网络通信流程
- **原因**：定义算法骨架，允许子类重写特定步骤

### 设计原则遵循：

#### SOLID原则
- **单一职责**：每个类只负责一个功能领域
- **开闭原则**：对扩展开放，对修改封闭
- **里氏替换**：子类可以替换父类
- **接口隔离**：接口职责单一，避免臃肿
- **依赖倒置**：依赖抽象而非具体实现

#### DRY原则 (Don't Repeat Yourself)
- 避免代码重复，提高维护性
- 通过基础工具类和公共组件实现代码复用

#### 高内聚低耦合
- 模块内部功能紧密相关
- 模块间依赖最小化
- 通过接口和事件总线实现解耦

## 4. 实现架构图

```
┌─────────────────────────────────────────────────────────────┐
│                    应用层 (SecurityGuardUI)                  │
├─────────────────────────────────────────────────────────────┤
│                    业务层 (ProtectionModules)                │
├─────────────────────────────────────────────────────────────┤
│                    核心层 (SecurityCore)                     │
├─────────────────────────────────────────────────────────────┤
│                      公共组件层                              │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐           │
│  │   Logger    │ │ EventBus    │ │ ThreadPool  │           │
│  └─────────────┘ └─────────────┘ └─────────────┘           │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐           │
│  │MemoryMgr    │ │    IPC      │ │ConfigMgr    │           │
│  └─────────────┘ └─────────────┘ └─────────────┘           │
├─────────────────────────────────────────────────────────────┤
│                     基础工具类层                             │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐           │
│  │StringUtils  │ │ FileUtils   │ │ProcessUtils │           │
│  └─────────────┘ └─────────────┘ └─────────────┘           │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐           │
│  │RegistryUtils│ │SystemUtils  │ │CryptoUtils  │           │
│  └─────────────┘ └─────────────┘ └─────────────┘           │
├─────────────────────────────────────────────────────────────┤
│                    系统API层 (Windows API)                   │
└─────────────────────────────────────────────────────────────┘
```

## 5. 必需组件优先级实现方案

### 第一优先级（核心基础）

#### Logger 日志组件
**实现方法**：
- `Initialize(const std::wstring& logPath, LogLevel level)` - 初始化日志系统
- `WriteLog(LogLevel level, const std::wstring& message)` - 写入日志
- `SetLogLevel(LogLevel level)` - 设置日志级别
- `FlushLogs()` - 强制刷新日志缓冲区
- `RotateLogFile()` - 日志文件轮转

**关键原因**：没有日志系统，无法进行问题诊断和系统监控，这是任何Windows系统级软件的生命线。

#### StringUtils 字符串工具类
**实现方法**：
- `WideToMultiByte(const std::wstring& wide)` - 宽字符转多字节
- `MultiByteToWide(const std::string& mb)` - 多字节转宽字符
- `FormatString(const std::wstring& format, ...)` - 格式化字符串
- `SplitString(const std::wstring& str, wchar_t delimiter)` - 字符串分割
- `NormalizePath(const std::wstring& path)` - 路径规范化

**关键原因**：Windows API混用ANSI和Unicode，字符串处理错误会导致系统崩溃或安全漏洞。

#### ProcessUtils 进程工具类
**实现方法**：
- `EnumProcesses()` - 枚举系统进程
- `GetProcessInfo(DWORD pid)` - 获取进程详细信息
- `IsProcessRunning(const std::wstring& processName)` - 检查进程是否运行
- `GetProcessModules(DWORD pid)` - 获取进程模块列表
- `ElevatePrivileges()` - 提升进程权限

**关键原因**：安全防护系统必须监控和管理进程，这是核心功能的基础。

### 第二优先级（系统交互）

#### FileUtils 文件操作工具类
**实现方法**：
- `ReadFile(const std::wstring& filePath)` - 安全读取文件
- `WriteFile(const std::wstring& filePath, const std::vector<BYTE>& data)` - 安全写入文件
- `FileExists(const std::wstring& filePath)` - 检查文件存在
- `GetFileHash(const std::wstring& filePath, HashType type)` - 计算文件哈希
- `SetFileAttributes(const std::wstring& filePath, DWORD attributes)` - 设置文件属性

#### RegistryUtils 注册表工具类
**实现方法**：
- `ReadRegistryValue(HKEY hKey, const std::wstring& subKey, const std::wstring& valueName)` - 读取注册表值
- `WriteRegistryValue(HKEY hKey, const std::wstring& subKey, const std::wstring& valueName, const std::wstring& value)` - 写入注册表值
- `DeleteRegistryKey(HKEY hKey, const std::wstring& subKey)` - 删除注册表键
- `EnumRegistryKeys(HKEY hKey, const std::wstring& subKey)` - 枚举注册表子键

### 第三优先级（高级功能）

#### ConfigManager 配置管理组件
**实现方法**：
- `LoadConfig(const std::wstring& configPath)` - 加载配置文件
- `SaveConfig(const std::wstring& configPath)` - 保存配置文件
- `GetConfigValue(const std::wstring& section, const std::wstring& key)` - 获取配置值
- `SetConfigValue(const std::wstring& section, const std::wstring& key, const std::wstring& value)` - 设置配置值
- `RegisterConfigChangeCallback(ConfigChangeCallback callback)` - 注册配置变更回调

#### CryptoUtils 加密工具类
**实现方法**：
- `CalculateHash(const std::vector<BYTE>& data, HashType type)` - 计算哈希值
- `AESEncrypt(const std::vector<BYTE>& data, const std::vector<BYTE>& key)` - AES加密
- `AESDecrypt(const std::vector<BYTE>& encryptedData, const std::vector<BYTE>& key)` - AES解密
- `VerifyDigitalSignature(const std::wstring& filePath)` - 验证数字签名

## 6. 第一阶段实现详细设计

### 6.1 StringUtils 字符串工具类

#### 设计模式选择
- **不需要使用设计模式**
- **理由**：StringUtils是纯工具类，所有方法均为静态方法，不需要维护状态，使用静态类即可，引入设计模式会增加不必要的复杂性。

#### 所在项目
- **SecurityCore项目**
- **理由**：作为最基础的工具类，应放在核心层，被所有其他模块引用。

#### 功能介绍
StringUtils类提供了一系列字符串处理的基础功能，包括字符集转换、格式化、分割、替换、大小写转换等操作。详细的实现方式请参考《StringUtils实现说明.md》文档。
```

### 6.2 Logger 日志组件

#### 设计模式选择
- **单例模式**
- **理由**：
  1. 全局唯一访问点，确保日志的一致性
  2. 避免多个日志实例导致的文件冲突
  3. 集中管理日志配置和资源

#### 所在项目
- **SecurityCore项目**
- **理由**：作为基础服务组件，应放在核心层，被所有其他模块引用。

#### 功能概述
- 提供多级别日志记录（Debug、Info、Warning、Error、Fatal）
- 支持日志文件轮转和管理
- 线程安全的日志写入
- 可配置的日志级别
- 支持强制刷新缓冲区

> 详细的实现说明请参考 [Logger实现说明文档.md](../docs/Logger实现说明文档.md)
```

### 6.3 ProcessUtils 进程工具类

#### 设计模式选择
- **不需要使用设计模式**
- **理由**：ProcessUtils主要提供静态工具方法，不需要维护复杂状态，使用静态类即可。

#### 所在项目
- **SecurityCore项目**
- **理由**：作为系统核心功能的支撑，应放在核心层，被安全防护相关模块引用。

#### 核心函数
```cpp
class ProcessUtils
{
public:
    // 枚举系统进程
    static std::vector<DWORD> EnumProcesses();
    
    // 获取进程详细信息
    static ProcessInfo GetProcessInfo(DWORD pid);
    
    // 检查进程是否运行
    static bool IsProcessRunning(const std::wstring& processName);
    
    // 获取进程模块列表
    static std::vector<ModuleInfo> GetProcessModules(DWORD pid);
    
    // 提升进程权限
    static bool ElevatePrivileges(const std::wstring& privilege = L"SeDebugPrivilege");
    
    // 终止进程
    static bool TerminateProcessById(DWORD pid);
    
    // 获取当前进程ID
    static DWORD GetCurrentProcessId();
    
    // 获取父进程ID
    static DWORD GetParentProcessId(DWORD pid);
    
    // 创建进程
    static bool CreateProcessWithArgs(const std::wstring& exePath, const std::wstring& args);
};
```

## 7. 专业判断说明

### 为什么不能只实现日志和字符串？

1. **系统完整性**：Windows安全防护系统如果缺少进程监控能力，就失去了核心价值
2. **依赖关系**：日志组件本身就需要文件操作和字符串处理的支持
3. **安全要求**：没有进程权限管理，无法实现有效的安全防护
4. **实际需求**：Hook引擎必须依赖进程工具类才能正常工作

### 实现顺序建议

1. **第一阶段**：StringUtils → Logger → ProcessUtils（核心三角）
2. **第二阶段**：FileUtils → RegistryUtils（系统交互）
3. **第三阶段**：ConfigManager → CryptoUtils（高级功能）

这种分阶段实现既保证了系统的基本可用性，又为后续扩展预留了空间。每个阶段都能产生可测试的功能模块，符合敏捷开发的最佳实践。

## 7. 代码注释规范

为了提高代码可读性和可维护性，所有基础工具类和公共组件必须遵循统一的注释规范。良好的注释不仅有助于其他开发者理解代码，也便于生成API文档和进行代码审查。

### 7.1 函数注释规范

所有公开函数必须使用以下格式进行注释：

```cpp
/**
 * @brief 简要描述函数功能
 * @param [IN/OUT] 参数名 参数详细说明
 * @return 返回值说明
 * @exception 可能抛出的异常说明（如适用）
 * @note 其他需要说明的事项（如适用）
 */
```

参数说明中的`[IN]`、`[OUT]`或`[IN/OUT]`标记用于明确参数的数据流向：
- `[IN]`：输入参数，函数不会修改其值
- `[OUT]`：输出参数，函数会写入新值
- `[IN/OUT]`：既作为输入又作为输出的参数

### 7.2 注释示例

以`StringUtils`类中的`ReplaceString`函数为例：

```cpp
/**
 * @brief 在字符串中查找并替换所有指定的子字符串
 * @param [IN] str 原始字符串，需要进行替换操作的源字符串
 * @param [IN] from 需要被替换的子字符串
 * @param [IN] to 替换成的新子字符串
 * @return std::wstring 替换操作完成后的新字符串
 */
static std::wstring ReplaceString(const std::wstring& str, const std::wstring& from, const std::wstring& to);
```

### 7.3 类注释规范

每个类定义前应添加类注释，说明类的用途、设计意图和使用方法：

```cpp
/**
 * @class 类名
 * @brief 类的简要描述
 * @details 类的详细描述，包括设计意图、使用场景等
 * @note 使用注意事项（如适用）
 */
```

### 7.4 文件头注释

每个源文件开头应包含文件头注释，说明文件内容、版权信息和修改历史：

```cpp
/**
 * @file 文件名
 * @brief 文件内容简要描述
 * @author 作者
 * @date 创建日期
 * @copyright 版权信息
 */
```

### 7.5 注释原则

1. **注释应解释"为什么"而非"是什么"**：代码本身应该清晰地表达它在做什么，注释应该解释为什么要这样做
2. **保持注释与代码同步更新**：修改代码时必须同步更新相关注释
3. **使用清晰简洁的语言**：避免冗长或模糊的描述
4. **关注复杂逻辑和算法**：对于复杂的实现逻辑，应提供足够的注释说明
5. **避免无意义的注释**：不要为了注释而注释，确保每条注释都有实际价值

遵循这些注释规范，可以显著提高代码的可读性和可维护性，减少团队协作中的沟通成本，并为新加入的开发者提供清晰的指导。

## 8. 基础工具类与Windows Hook技术的关联

基础工具类和公共组件为Windows Hook技术的实现提供了关键支持。以下是主要工具类与Hook技术的关联：

### 8.1 StringUtils与Hook技术

**关联点**：
- **路径处理**：Hook过程中需要处理DLL路径、模块路径等字符串
- **错误信息格式化**：格式化Hook过程中的错误信息和日志
- **参数解析**：解析和处理Hook函数的字符串参数
- **字符集转换**：在不同Windows API之间转换字符集（ANSI/Unicode）

**实际应用**：
```cpp
// Hook安装过程中的路径规范化
std::wstring dllPath = StringUtils::NormalizePath(L"C:\\Hook\\MyHook.dll");

// 格式化Hook错误信息
std::wstring errorMsg = StringUtils::FormatString(L"Hook失败，错误码: %d", GetLastError());
```

### 8.2 ProcessUtils与Hook技术

**关联点**：
- **进程注入**：实现DLL注入所需的进程操作
- **模块信息获取**：获取需要Hook的模块基址和导出函数
- **权限提升**：获取Hook所需的系统权限
- **进程监控**：监控被Hook进程的状态

**实际应用**：
```cpp
// 提升权限以安装系统级Hook
ProcessUtils::ElevatePrivileges(L"SeDebugPrivilege");

// 获取目标进程模块信息用于IAT Hook
std::vector<ModuleInfo> modules = ProcessUtils::GetProcessModules(targetPid);
```

### 8.3 Logger与Hook技术

**关联点**：
- **Hook事件记录**：记录Hook的安装、卸载和触发事件
- **调试信息**：记录Hook过程中的详细调试信息
- **性能分析**：记录Hook函数的执行时间和性能影响
- **异常捕获**：记录Hook过程中的异常和错误

**实际应用**：
```cpp
// 记录Hook安装事件
Logger::GetInstance().Info(StringUtils::FormatString(L"成功Hook函数: %s", functionName.c_str()));

// 记录Hook触发事件
Logger::GetInstance().Debug(L"Hook函数被调用，参数已被修改");
```

### 8.4 其他工具类与Hook的关联

- **FileUtils**：读取和写入Hook配置文件、保存Hook状态
- **RegistryUtils**：管理Hook相关的注册表配置
- **CryptoUtils**：验证Hook模块的完整性，防止被篡改
- **ConfigManager**：管理Hook策略和配置

### 8.5 设计考量

在实现Windows Hook技术时，基础工具类的设计需要特别注意：

1. **性能优化**：Hook函数通常在关键路径上，工具类的性能直接影响Hook的效率
2. **线程安全**：Hook可能在多线程环境中触发，工具类必须是线程安全的
3. **异常处理**：完善的异常处理机制，防止Hook导致系统崩溃
4. **资源管理**：严格控制资源使用，避免Hook造成资源泄漏
5. **兼容性**：考虑不同Windows版本的API差异，确保Hook在各版本系统上正常工作

通过合理设计和使用这些基础工具类，可以大幅提高Windows Hook技术的可靠性、可维护性和安全性。

## 9. 总结

这种分层设计架构确保了系统的：
- **可维护性**：清晰的模块划分和职责分离
- **可扩展性**：通过设计模式支持功能扩展
- **稳定性**：统一的错误处理和资源管理
- **性能**：优化的内存和线程管理
- **安全性**：加密和权限控制机制

为Windows安全防护系统提供了坚实的技术基础和架构支撑。