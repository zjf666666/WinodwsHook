# 基础工具类和公共组件设计说明

## 1. 基础工具类的功能与用途

基础工具类是整个Windows安全防护系统的底层支撑，提供通用的、可复用的功能模块：

### 核心功能模块：

#### 字符串处理工具类 (StringUtils)
- **功能**：
  - 宽字符与多字节字符转换
  - 字符串格式化、分割、替换
  - 路径规范化处理
- **用途**：统一字符串处理标准，避免编码问题

#### 文件操作工具类 (FileUtils)
- **功能**：
  - 文件读写、复制、移动、删除
  - 目录遍历和创建
  - 文件属性获取和修改
  - 临时文件管理
- **用途**：封装Windows文件API，提供安全的文件操作接口

#### 注册表工具类 (RegistryUtils)
- **功能**：
  - 注册表键值的读取、写入、删除
  - 注册表权限检查
  - 注册表监控
- **用途**：统一注册表操作，支持配置管理和系统监控

#### 进程工具类 (ProcessUtils)
- **功能**：
  - 进程枚举和信息获取
  - 进程创建、终止、挂起
  - 进程权限提升
  - 模块枚举和信息获取
- **用途**：支持进程监控和管理功能

#### 系统信息工具类 (SystemUtils)
- **功能**：
  - 系统版本、架构信息获取
  - 硬件信息收集
  - 系统性能监控
- **用途**：提供系统环境检测和适配能力

#### 加密工具类 (CryptoUtils)
- **功能**：
  - 哈希计算（MD5、SHA256等）
  - 对称加密/解密（AES）
  - 数字签名验证
- **用途**：保护敏感数据和验证文件完整性

## 2. 公共组件的功能与用途

公共组件是系统级的服务模块，为各个子系统提供统一的基础服务：

### 核心组件模块：

#### 日志组件 (Logger)
- **功能**：
  - 多级别日志记录（Debug、Info、Warning、Error）
  - 日志文件轮转和压缩
  - 实时日志查看
  - 性能日志统计
- **用途**：统一日志管理，支持问题诊断和性能分析

#### 配置管理组件 (ConfigManager)
- **功能**：
  - 配置文件读写和解析
  - 配置热更新
  - 配置验证和默认值处理
  - 配置加密存储
- **用途**：集中管理系统配置，支持动态配置更新

#### 事件总线组件 (EventBus)
- **功能**：
  - 模块间消息传递
  - 事件订阅和发布
  - 异步事件处理
  - 事件优先级管理
- **用途**：解耦模块间依赖，实现松耦合架构

#### 线程池组件 (ThreadPool)
- **功能**：
  - 工作线程管理
  - 任务队列调度
  - 线程优先级控制
  - 资源限制和监控
- **用途**：优化系统性能，避免频繁创建销毁线程

#### 内存管理组件 (MemoryManager)
- **功能**：
  - 内存池管理
  - 内存泄漏检测
  - 内存使用统计
  - 智能指针封装
- **用途**：提高内存使用效率，防止内存泄漏

#### 通信组件 (IPC)
- **功能**：
  - 进程间通信（命名管道、共享内存）
  - 网络通信封装
  - 消息序列化/反序列化
  - 通信加密和认证
- **用途**：支持模块间和进程间的安全通信

## 3. 设计模式及原因

### 基础工具类采用的设计模式：

#### 单例模式 (Singleton)
- **应用场景**：日志组件、配置管理组件
- **原因**：确保全局唯一实例，避免资源冲突，提供全局访问点

#### 工厂模式 (Factory)
- **应用场景**：加密算法创建、文件操作对象创建
- **原因**：封装对象创建逻辑，支持运行时选择具体实现

#### 策略模式 (Strategy)
- **应用场景**：不同加密算法、不同文件操作策略
- **原因**：支持算法动态切换，提高代码可扩展性

### 公共组件采用的设计模式：

#### 观察者模式 (Observer)
- **应用场景**：事件总线、配置变更通知
- **原因**：实现松耦合的事件通知机制，支持一对多依赖关系

#### 命令模式 (Command)
- **应用场景**：线程池任务调度、操作撤销
- **原因**：将请求封装为对象，支持队列、日志和撤销操作

#### 适配器模式 (Adapter)
- **应用场景**：不同版本Windows API适配、第三方库集成
- **原因**：统一接口标准，屏蔽底层差异

#### 装饰器模式 (Decorator)
- **应用场景**：日志功能增强、加密传输
- **原因**：动态添加功能，避免类爆炸问题

#### 模板方法模式 (Template Method)
- **应用场景**：文件操作流程、网络通信流程
- **原因**：定义算法骨架，允许子类重写特定步骤

### 设计原则遵循：

#### SOLID原则
- **单一职责**：每个类只负责一个功能领域
- **开闭原则**：对扩展开放，对修改封闭
- **里氏替换**：子类可以替换父类
- **接口隔离**：接口职责单一，避免臃肿
- **依赖倒置**：依赖抽象而非具体实现

#### DRY原则 (Don't Repeat Yourself)
- 避免代码重复，提高维护性
- 通过基础工具类和公共组件实现代码复用

#### 高内聚低耦合
- 模块内部功能紧密相关
- 模块间依赖最小化
- 通过接口和事件总线实现解耦

## 4. 实现架构图

```
┌─────────────────────────────────────────────────────────────┐
│                    应用层 (SecurityGuardUI)                  │
├─────────────────────────────────────────────────────────────┤
│                    业务层 (ProtectionModules)                │
├─────────────────────────────────────────────────────────────┤
│                    核心层 (SecurityCore)                     │
├─────────────────────────────────────────────────────────────┤
│                      公共组件层                              │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐           │
│  │   Logger    │ │ EventBus    │ │ ThreadPool  │           │
│  └─────────────┘ └─────────────┘ └─────────────┘           │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐           │
│  │MemoryMgr    │ │    IPC      │ │ConfigMgr    │           │
│  └─────────────┘ └─────────────┘ └─────────────┘           │
├─────────────────────────────────────────────────────────────┤
│                     基础工具类层                             │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐           │
│  │StringUtils  │ │ FileUtils   │ │ProcessUtils │           │
│  └─────────────┘ └─────────────┘ └─────────────┘           │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐           │
│  │RegistryUtils│ │SystemUtils  │ │CryptoUtils  │           │
│  └─────────────┘ └─────────────┘ └─────────────┘           │
├─────────────────────────────────────────────────────────────┤
│                    系统API层 (Windows API)                   │
└─────────────────────────────────────────────────────────────┘
```

## 5. 必需组件优先级实现方案

### 第一优先级（核心基础）

#### Logger 日志组件
**实现方法**：
- `Initialize(const std::wstring& logPath, LogLevel level)` - 初始化日志系统
- `WriteLog(LogLevel level, const std::wstring& message)` - 写入日志
- `SetLogLevel(LogLevel level)` - 设置日志级别
- `FlushLogs()` - 强制刷新日志缓冲区
- `RotateLogFile()` - 日志文件轮转

**关键原因**：没有日志系统，无法进行问题诊断和系统监控，这是任何Windows系统级软件的生命线。

#### StringUtils 字符串工具类
**实现方法**：
- `WideToMultiByte(const std::wstring& wide)` - 宽字符转多字节
- `MultiByteToWide(const std::string& mb)` - 多字节转宽字符
- `FormatString(const std::wstring& format, ...)` - 格式化字符串
- `SplitString(const std::wstring& str, wchar_t delimiter)` - 字符串分割
- `NormalizePath(const std::wstring& path)` - 路径规范化

**关键原因**：Windows API混用ANSI和Unicode，字符串处理错误会导致系统崩溃或安全漏洞。

#### ProcessUtils 进程工具类
**实现方法**：
- `EnumProcesses()` - 枚举系统进程
- `GetProcessInfo(DWORD pid)` - 获取进程详细信息
- `IsProcessRunning(const std::wstring& processName)` - 检查进程是否运行
- `GetProcessModules(DWORD pid)` - 获取进程模块列表
- `ElevatePrivileges()` - 提升进程权限

**关键原因**：安全防护系统必须监控和管理进程，这是核心功能的基础。

### 第二优先级（系统交互）

#### FileUtils 文件操作工具类
**实现方法**：
- `ReadFile(const std::wstring& filePath)` - 安全读取文件
- `WriteFile(const std::wstring& filePath, const std::vector<BYTE>& data)` - 安全写入文件
- `FileExists(const std::wstring& filePath)` - 检查文件存在
- `GetFileHash(const std::wstring& filePath, HashType type)` - 计算文件哈希
- `SetFileAttributes(const std::wstring& filePath, DWORD attributes)` - 设置文件属性

#### RegistryUtils 注册表工具类
**实现方法**：
- `ReadRegistryValue(HKEY hKey, const std::wstring& subKey, const std::wstring& valueName)` - 读取注册表值
- `WriteRegistryValue(HKEY hKey, const std::wstring& subKey, const std::wstring& valueName, const std::wstring& value)` - 写入注册表值
- `DeleteRegistryKey(HKEY hKey, const std::wstring& subKey)` - 删除注册表键
- `EnumRegistryKeys(HKEY hKey, const std::wstring& subKey)` - 枚举注册表子键

### 第三优先级（高级功能）

#### ConfigManager 配置管理组件
**实现方法**：
- `LoadConfig(const std::wstring& configPath)` - 加载配置文件
- `SaveConfig(const std::wstring& configPath)` - 保存配置文件
- `GetConfigValue(const std::wstring& section, const std::wstring& key)` - 获取配置值
- `SetConfigValue(const std::wstring& section, const std::wstring& key, const std::wstring& value)` - 设置配置值
- `RegisterConfigChangeCallback(ConfigChangeCallback callback)` - 注册配置变更回调

#### CryptoUtils 加密工具类
**实现方法**：
- `CalculateHash(const std::vector<BYTE>& data, HashType type)` - 计算哈希值
- `AESEncrypt(const std::vector<BYTE>& data, const std::vector<BYTE>& key)` - AES加密
- `AESDecrypt(const std::vector<BYTE>& encryptedData, const std::vector<BYTE>& key)` - AES解密
- `VerifyDigitalSignature(const std::wstring& filePath)` - 验证数字签名

## 6. 专业判断说明

### 为什么不能只实现日志和字符串？

1. **系统完整性**：Windows安全防护系统如果缺少进程监控能力，就失去了核心价值
2. **依赖关系**：日志组件本身就需要文件操作和字符串处理的支持
3. **安全要求**：没有进程权限管理，无法实现有效的安全防护
4. **实际需求**：Hook引擎必须依赖进程工具类才能正常工作

### 实现顺序建议

1. **第一阶段**：StringUtils → Logger → ProcessUtils（核心三角）
2. **第二阶段**：FileUtils → RegistryUtils（系统交互）
3. **第三阶段**：ConfigManager → CryptoUtils（高级功能）

这种分阶段实现既保证了系统的基本可用性，又为后续扩展预留了空间。每个阶段都能产生可测试的功能模块，符合敏捷开发的最佳实践。

## 7. 总结

这种分层设计架构确保了系统的：
- **可维护性**：清晰的模块划分和职责分离
- **可扩展性**：通过设计模式支持功能扩展
- **稳定性**：统一的错误处理和资源管理
- **性能**：优化的内存和线程管理
- **安全性**：加密和权限控制机制

为Windows安全防护系统提供了坚实的技术基础和架构支撑。