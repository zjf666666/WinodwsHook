# 无线远程注入实现说明

## 1. 概述

无线远程注入是 Windows 安全防护系统中的高级功能模块，通过网络连接实现对远程计算机进程的代码注入，无需物理接触目标设备即可实现监控和防护。该模块结合了网络通信、进程操作和内存注入技术，为系统提供了远程安全监控和响应能力。

无线远程注入技术主要应用于企业级安全管理、远程安全审计、分布式安全防护等场景，能够在不中断目标系统正常运行的情况下，实现安全策略的远程部署和执行。

## 2. 所属项目与架构位置

### 2.1 所属项目

无线远程注入模块应位于 `WindowsSecurityGuard` 项目的 `RemoteInjection` 子模块中，作为 HookEngine 的扩展组件。

### 2.2 架构位置

在整体系统架构中，无线远程注入模块的位置如下：

```
┌─────────────────────────────────────────────────────────────┐
│                    应用层 (SecurityGuardUI)                  │
├─────────────────────────────────────────────────────────────┤
│                    业务层 (ProtectionModules)                │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐           │
│  │ 本地防护    │ │ 远程管理    │ │ 策略控制    │           │
│  └─────────────┘ └─────────────┘ └─────────────┘           │
├─────────────────────────────────────────────────────────────┤
│                    核心层 (SecurityCore)                     │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐           │
│  │ HookEngine  │ │RemoteInject │ │ 其他核心模块│           │
│  └─────────────┘ └─────────────┘ └─────────────┘           │
├─────────────────────────────────────────────────────────────┤
│                      公共组件层                              │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐           │
│  │   Logger    │ │ EventBus    │ │ ThreadPool  │           │
│  └─────────────┘ └─────────────┘ └─────────────┘           │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐           │
│  │MemoryMgr    │ │    IPC      │ │ConfigMgr    │           │
│  └─────────────┘ └─────────────┘ └─────────────┘           │
├─────────────────────────────────────────────────────────────┤
│                     基础工具类层                             │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐           │
│  │StringUtils  │ │ FileUtils   │ │ProcessUtils │           │
│  └─────────────┘ └─────────────┘ └─────────────┘           │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐           │
│  │RegistryUtils│ │SystemUtils  │ │MemoryUtils  │           │
│  └─────────────┘ └─────────────┘ └─────────────┘           │
├─────────────────────────────────────────────────────────────┤
│                    系统API层 (Windows API)                   │
└─────────────────────────────────────────────────────────────┘
```

无线远程注入模块位于核心层的 RemoteInject 子模块，依赖基础工具类层和公共组件层，为业务层提供远程注入服务。

## 3. 设计模式选择

### 3.1 主要设计模式

#### 命令模式 (Command Pattern)

**选择原因**：
1. **操作封装**：将远程注入操作封装为对象，便于传输和执行
2. **参数化**：支持不同类型的注入操作和参数配置
3. **队列化**：支持注入操作的排队和批处理
4. **撤销支持**：提供操作回滚机制，增强系统稳定性
5. **日志记录**：便于记录所有远程操作，支持审计和问题排查

**实现方式**：
```cpp
// 注入命令接口
class IInjectionCommand {
public:
    virtual ~IInjectionCommand() {}
    virtual bool Execute(const RemoteTarget& target) = 0;
    virtual bool Undo(const RemoteTarget& target) = 0;
    virtual std::wstring GetCommandName() const = 0;
};

// 具体命令实现
class DllInjectionCommand : public IInjectionCommand {
private:
    std::wstring m_dllPath;
    InjectionMethod m_method;
    
public:
    DllInjectionCommand(const std::wstring& dllPath, InjectionMethod method)
        : m_dllPath(dllPath), m_method(method) {}
        
    virtual bool Execute(const RemoteTarget& target) override;
    virtual bool Undo(const RemoteTarget& target) override;
    virtual std::wstring GetCommandName() const override { return L"DllInjection"; }
};
```

#### 策略模式 (Strategy Pattern)

**选择原因**：
1. **算法封装**：封装不同的注入技术实现，如CreateRemoteThread、QueueUserAPC等
2. **运行时选择**：根据目标系统环境和安全级别选择最合适的注入策略
3. **消除条件判断**：避免使用大量的条件语句判断不同注入类型
4. **开闭原则**：新增注入技术只需添加新的策略类，无需修改现有代码

**实现方式**：
```cpp
// 注入策略接口
class IInjectionStrategy {
public:
    virtual ~IInjectionStrategy() {}
    virtual bool Inject(HANDLE hProcess, const std::wstring& dllPath) = 0;
    virtual bool Eject(HANDLE hProcess, const std::wstring& dllPath) = 0;
    virtual std::wstring GetStrategyName() const = 0;
};

// 具体策略实现
class CreateRemoteThreadStrategy : public IInjectionStrategy {
public:
    virtual bool Inject(HANDLE hProcess, const std::wstring& dllPath) override;
    virtual bool Eject(HANDLE hProcess, const std::wstring& dllPath) override;
    virtual std::wstring GetStrategyName() const override { return L"CreateRemoteThread"; }
};

class QueueUserAPCStrategy : public IInjectionStrategy {
public:
    virtual bool Inject(HANDLE hProcess, const std::wstring& dllPath) override;
    virtual bool Eject(HANDLE hProcess, const std::wstring& dllPath) override;
    virtual std::wstring GetStrategyName() const override { return L"QueueUserAPC"; }
};
```

#### 观察者模式 (Observer Pattern)

**选择原因**：
1. **状态通知**：实时通知注入操作的状态变化
2. **解耦通知**：注入操作与状态监控解耦
3. **多方监控**：支持多个组件同时监控注入状态
4. **事件驱动**：构建事件驱动的注入流程

**实现方式**：
```cpp
// 注入观察者接口
class IInjectionObserver {
public:
    virtual ~IInjectionObserver() {}
    virtual void OnInjectionStarted(const RemoteTarget& target, const IInjectionCommand& command) = 0;
    virtual void OnInjectionCompleted(const RemoteTarget& target, const IInjectionCommand& command, bool success) = 0;
    virtual void OnInjectionError(const RemoteTarget& target, const IInjectionCommand& command, const std::wstring& error) = 0;
};

// 注入管理器中的观察者支持
class RemoteInjectionManager {
private:
    std::vector<IInjectionObserver*> m_observers;
    
public:
    void AddObserver(IInjectionObserver* observer);
    void RemoveObserver(IInjectionObserver* observer);
    void NotifyInjectionStarted(const RemoteTarget& target, const IInjectionCommand& command);
    void NotifyInjectionCompleted(const RemoteTarget& target, const IInjectionCommand& command, bool success);
    void NotifyInjectionError(const RemoteTarget& target, const IInjectionCommand& command, const std::wstring& error);
};
```

### 3.2 辅助设计模式

#### 工厂模式 (Factory Pattern)

**选择原因**：
1. **创建封装**：封装不同注入策略和命令的创建逻辑
2. **配置驱动**：根据配置创建合适的注入组件
3. **依赖管理**：集中管理组件依赖关系

**实现方式**：
```cpp
class InjectionFactory {
public:
    static IInjectionStrategy* CreateStrategy(InjectionMethod method);
    static IInjectionCommand* CreateCommand(CommandType type, const CommandParams& params);
};
```

#### 适配器模式 (Adapter Pattern)

**选择原因**：
1. **兼容性**：适配不同版本Windows系统的注入API
2. **接口统一**：为不同的注入技术提供统一接口
3. **平台差异**：处理32位和64位系统的差异

**实现方式**：
```cpp
class WindowsVersionAdapter {
public:
    static BOOL InjectDllForWindowsVersion(HANDLE hProcess, const std::wstring& dllPath);
};
```

## 4. 核心数据结构

### 4.1 远程目标结构体

```cpp
struct RemoteTarget {
    std::wstring HostName;        // 目标主机名或IP地址
    DWORD ProcessId;              // 目标进程ID
    std::wstring ProcessName;     // 目标进程名称
    DWORD SessionId;              // 会话ID
    bool Is64Bit;                 // 是否为64位进程
    SecurityLevel SecurityLevel;  // 目标安全级别
    
    RemoteTarget() : ProcessId(0), SessionId(0), Is64Bit(false), SecurityLevel(SecurityLevel::Normal) {}
};
```

### 4.2 注入方法枚举

```cpp
enum class InjectionMethod {
    CreateRemoteThread,    // 使用CreateRemoteThread API
    QueueUserAPC,         // 使用QueueUserAPC API
    SetWindowsHookEx,     // 使用SetWindowsHookEx API
    ReflectiveInjection,  // 反射式注入
    ManualMapping,        // 手动映射
    ThreadHijacking       // 线程劫持
};
```

### 4.3 注入结果结构体

```cpp
struct InjectionResult {
    bool Success;                  // 注入是否成功
    std::wstring ErrorMessage;    // 错误信息
    DWORD ErrorCode;              // 错误代码
    DWORD InjectedModuleBase;     // 注入模块基址
    std::wstring CommandId;       // 命令ID
    
    InjectionResult() : Success(false), ErrorCode(0), InjectedModuleBase(0) {}
};
```

## 5. 核心接口设计

### 5.1 远程注入管理器

```cpp
class RemoteInjectionManager {
public:
    // 单例访问点
    static RemoteInjectionManager& GetInstance();
    
    // 连接管理
    bool Connect(const std::wstring& hostName, const ConnectionOptions& options);
    void Disconnect(const std::wstring& hostName);
    bool IsConnected(const std::wstring& hostName) const;
    
    // 进程管理
    std::vector<RemoteProcessInfo> EnumRemoteProcesses(const std::wstring& hostName);
    RemoteProcessInfo GetRemoteProcessInfo(const std::wstring& hostName, DWORD processId);
    
    // 注入操作
    InjectionResult InjectDll(const RemoteTarget& target, const std::wstring& dllPath, InjectionMethod method);
    InjectionResult EjectDll(const RemoteTarget& target, const std::wstring& dllPath);
    InjectionResult ExecuteCommand(const RemoteTarget& target, IInjectionCommand* command);
    
    // 命令队列管理
    void QueueCommand(const RemoteTarget& target, IInjectionCommand* command);
    void ExecuteQueuedCommands(const RemoteTarget& target);
    void ClearCommandQueue(const RemoteTarget& target);
    
    // 观察者管理
    void AddObserver(IInjectionObserver* observer);
    void RemoveObserver(IInjectionObserver* observer);
    
private:
    // 私有构造和析构函数（单例模式）
    RemoteInjectionManager();
    ~RemoteInjectionManager();
    
    // 禁用拷贝构造和赋值操作
    RemoteInjectionManager(const RemoteInjectionManager&) = delete;
    RemoteInjectionManager& operator=(const RemoteInjectionManager&) = delete;
    
    // 内部实现细节
    // ...
};
```

### 5.2 远程通信接口

```cpp
class IRemoteCommunication {
public:
    virtual ~IRemoteCommunication() {}
    
    // 连接管理
    virtual bool Connect(const std::wstring& hostName, const ConnectionOptions& options) = 0;
    virtual void Disconnect() = 0;
    virtual bool IsConnected() const = 0;
    
    // 数据传输
    virtual bool SendData(const std::vector<BYTE>& data) = 0;
    virtual bool ReceiveData(std::vector<BYTE>& outData, DWORD timeout = INFINITE) = 0;
    
    // 远程执行
    virtual bool ExecuteRemoteFunction(const RemoteFunctionCall& functionCall, RemoteFunctionResult& result) = 0;
};
```

### 5.3 注入策略选择器

```cpp
class InjectionStrategySelector {
public:
    // 根据目标环境选择最佳注入策略
    static IInjectionStrategy* SelectBestStrategy(const RemoteTarget& target);
    
    // 检查注入策略是否适用于目标
    static bool IsStrategyApplicable(InjectionMethod method, const RemoteTarget& target);
    
    // 获取目标支持的所有注入策略
    static std::vector<InjectionMethod> GetSupportedStrategies(const RemoteTarget& target);
};
```

## 6. 调用方式与流程

### 6.1 基本调用流程

无线远程注入的基本调用流程如下：

1. **初始化连接**：连接到远程目标主机
2. **获取进程信息**：枚举远程主机上的进程
3. **选择目标进程**：确定需要注入的目标进程
4. **创建注入命令**：创建适合目标环境的注入命令
5. **执行注入操作**：执行注入命令，将DLL注入到远程进程
6. **监控注入状态**：通过观察者模式监控注入过程
7. **处理结果**：处理注入结果，包括成功和失败情况

### 6.2 代码调用示例

```cpp
// 获取远程注入管理器实例
RemoteInjectionManager& injectionManager = RemoteInjectionManager::GetInstance();

// 连接到远程主机
ConnectionOptions options;
options.Timeout = 5000;  // 5秒超时
options.Encrypted = true; // 使用加密连接

if (!injectionManager.Connect(L"192.168.1.100", options)) {
    Logger::GetInstance().Error(L"无法连接到远程主机");
    return;
}

// 枚举远程进程
std::vector<RemoteProcessInfo> processes = injectionManager.EnumRemoteProcesses(L"192.168.1.100");

// 查找目标进程
RemoteTarget target;
target.HostName = L"192.168.1.100";

for (const auto& process : processes) {
    if (process.ProcessName == L"target.exe") {
        target.ProcessId = process.ProcessId;
        target.ProcessName = process.ProcessName;
        target.Is64Bit = process.Is64Bit;
        break;
    }
}

if (target.ProcessId == 0) {
    Logger::GetInstance().Error(L"未找到目标进程");
    injectionManager.Disconnect(L"192.168.1.100");
    return;
}

// 执行DLL注入
InjectionResult result = injectionManager.InjectDll(
    target,
    L"C:\\SecurityGuard\\Hooks\\monitor.dll",
    InjectionMethod::CreateRemoteThread
);

// 处理注入结果
if (result.Success) {
    Logger::GetInstance().Info(StringUtils::FormatString(
        L"成功注入DLL到远程进程，模块基址: 0x%08X",
        result.InjectedModuleBase
    ));
} else {
    Logger::GetInstance().Error(StringUtils::FormatString(
        L"注入DLL失败，错误: %s (代码: %d)",
        result.ErrorMessage.c_str(),
        result.ErrorCode
    ));
}

// 断开连接
injectionManager.Disconnect(L"192.168.1.100");
```

### 6.3 高级调用方式

对于更复杂的注入场景，可以使用命令模式和队列：

```cpp
// 创建多个注入命令
IInjectionCommand* dllCommand = InjectionFactory::CreateCommand(
    CommandType::DllInjection,
    {{
        {L"DllPath", L"C:\\SecurityGuard\\Hooks\\monitor.dll"},
        {L"Method", L"CreateRemoteThread"}
    }}
);

IInjectionCommand* configCommand = InjectionFactory::CreateCommand(
    CommandType::WriteConfig,
    {{
        {L"ConfigPath", L"C:\\ProgramData\\SecurityGuard\\config.ini"},
        {L"ConfigData", L"LogLevel=Debug\nEnableMonitoring=1"}
    }}
);

IInjectionCommand* startCommand = InjectionFactory::CreateCommand(
    CommandType::StartMonitoring,
    {{}}
);

// 将命令加入队列
injectionManager.QueueCommand(target, dllCommand);
injectionManager.QueueCommand(target, configCommand);
injectionManager.QueueCommand(target, startCommand);

// 执行队列中的所有命令
injectionManager.ExecuteQueuedCommands(target);
```

## 7. 安全性与稳定性考虑

### 7.1 通信加密

无线远程注入涉及敏感操作，必须确保通信安全：

```cpp
class SecureRemoteCommunication : public IRemoteCommunication {
private:
    std::unique_ptr<ICryptoProvider> m_cryptoProvider;
    
public:
    SecureRemoteCommunication() {
        m_cryptoProvider = std::make_unique<AESCryptoProvider>();
    }
    
    virtual bool SendData(const std::vector<BYTE>& data) override {
        // 加密数据
        std::vector<BYTE> encryptedData;
        if (!m_cryptoProvider->Encrypt(data, encryptedData)) {
            return false;
        }
        
        // 发送加密数据
        // ...
        
        return true;
    }
    
    virtual bool ReceiveData(std::vector<BYTE>& outData, DWORD timeout) override {
        // 接收加密数据
        std::vector<BYTE> encryptedData;
        // ...
        
        // 解密数据
        return m_cryptoProvider->Decrypt(encryptedData, outData);
    }
};
```

### 7.2 身份验证

确保只有授权用户才能执行远程注入操作：

```cpp
class AuthenticationManager {
public:
    static bool Authenticate(const std::wstring& hostName, const Credentials& credentials);
    static bool VerifyPermission(const std::wstring& hostName, const std::wstring& operation);
};

bool RemoteInjectionManager::Connect(const std::wstring& hostName, const ConnectionOptions& options) {
    // 验证身份
    if (!AuthenticationManager::Authenticate(hostName, options.Credentials)) {
        Logger::GetInstance().Error(L"身份验证失败");
        return false;
    }
    
    // 验证权限
    if (!AuthenticationManager::VerifyPermission(hostName, L"RemoteInjection")) {
        Logger::GetInstance().Error(L"没有执行远程注入的权限");
        return false;
    }
    
    // 建立连接
    // ...
    
    return true;
}
```

### 7.3 错误恢复

实现错误恢复机制，确保注入失败不会导致远程系统不稳定：

```cpp
class InjectionRecoveryManager {
public:
    static void RegisterRecoveryPoint(const RemoteTarget& target, const InjectionState& state);
    static bool RestoreFromRecoveryPoint(const RemoteTarget& target);
    static void CleanupRecoveryPoints(const RemoteTarget& target);
};

InjectionResult RemoteInjectionManager::InjectDll(const RemoteTarget& target, const std::wstring& dllPath, InjectionMethod method) {
    // 注册恢复点
    InjectionState initialState;
    // 获取初始状态...
    InjectionRecoveryManager::RegisterRecoveryPoint(target, initialState);
    
    InjectionResult result;
    try {
        // 执行注入...
    }
    catch (const std::exception& ex) {
        // 发生异常，恢复到初始状态
        InjectionRecoveryManager::RestoreFromRecoveryPoint(target);
        
        result.Success = false;
        result.ErrorMessage = StringUtils::MultiByteToWide(ex.what());
        result.ErrorCode = GetLastError();
    }
    
    // 清理恢复点
    InjectionRecoveryManager::CleanupRecoveryPoints(target);
    
    return result;
}
```

## 8. 性能优化建议

### 8.1 连接池管理

对于需要频繁操作的远程主机，可以实现连接池管理，避免重复建立连接：

```cpp
class ConnectionPool {
private:
    std::unordered_map<std::wstring, std::shared_ptr<IRemoteCommunication>> m_connections;
    std::mutex m_mutex;
    
public:
    std::shared_ptr<IRemoteCommunication> GetConnection(const std::wstring& hostName);
    void ReleaseConnection(const std::wstring& hostName);
    void CloseIdleConnections(DWORD idleTimeoutMs);
};
```

### 8.2 批量操作

对于需要在多个远程进程中执行相同操作的场景，可以实现批量操作接口：

```cpp
struct BatchInjectionResult {
    std::unordered_map<DWORD, InjectionResult> Results;  // 进程ID -> 注入结果
    int SuccessCount;
    int FailureCount;
};

BatchInjectionResult RemoteInjectionManager::BatchInjectDll(
    const std::wstring& hostName,
    const std::vector<DWORD>& processIds,
    const std::wstring& dllPath,
    InjectionMethod method
);
```

### 8.3 异步操作

对于耗时较长的注入操作，可以实现异步接口：

```cpp
class AsyncInjectionTask {
public:
    using CompletionCallback = std::function<void(const InjectionResult&)>;
    
    AsyncInjectionTask(const RemoteTarget& target, IInjectionCommand* command);
    void Execute();
    void Cancel();
    void SetCompletionCallback(CompletionCallback callback);
    InjectionTaskStatus GetStatus() const;
};

std::shared_ptr<AsyncInjectionTask> RemoteInjectionManager::InjectDllAsync(
    const RemoteTarget& target,
    const std::wstring& dllPath,
    InjectionMethod method,
    AsyncInjectionTask::CompletionCallback callback
);
```

## 9. 兼容性考虑

### 9.1 不同Windows版本的兼容性

无线远程注入需要考虑在不同Windows版本上的兼容性问题：

```cpp
class WindowsVersionHelper {
public:
    static WindowsVersion GetRemoteWindowsVersion(const std::wstring& hostName);
    static bool IsInjectionMethodSupported(InjectionMethod method, WindowsVersion version);
    static InjectionMethod GetFallbackMethod(InjectionMethod preferredMethod, WindowsVersion version);
};

InjectionMethod InjectionStrategySelector::SelectBestMethod(const RemoteTarget& target) {
    // 获取远程系统版本
    WindowsVersion version = WindowsVersionHelper::GetRemoteWindowsVersion(target.HostName);
    
    // 根据系统版本选择最佳注入方法
    if (version >= WindowsVersion::Windows10) {
        return InjectionMethod::ManualMapping;  // Windows 10及以上使用手动映射
    }
    else if (version >= WindowsVersion::Windows7) {
        return InjectionMethod::CreateRemoteThread;  // Windows 7/8/8.1使用CreateRemoteThread
    }
    else {
        return InjectionMethod::SetWindowsHookEx;  // 较旧系统使用SetWindowsHookEx
    }
}
```

### 9.2 32位和64位进程兼容性

处理32位和64位进程的差异：

```cpp
class ArchitectureHelper {
public:
    static bool Is64BitProcess(HANDLE hProcess);
    static bool Is64BitDll(const std::wstring& dllPath);
    static std::wstring GetArchitectureSpecificDll(const std::wstring& baseDllPath, bool is64Bit);
};

InjectionResult RemoteInjectionManager::InjectDll(const RemoteTarget& target, const std::wstring& dllPath, InjectionMethod method) {
    // 检查DLL和目标进程的架构是否匹配
    bool isDll64Bit = ArchitectureHelper::Is64BitDll(dllPath);
    
    if (isDll64Bit != target.Is64Bit) {
        // 架构不匹配，尝试查找匹配的DLL
        std::wstring compatibleDllPath = ArchitectureHelper::GetArchitectureSpecificDll(dllPath, target.Is64Bit);
        
        if (compatibleDllPath.empty()) {
            // 没有找到匹配的DLL
            InjectionResult result;
            result.Success = false;
            result.ErrorMessage = L"DLL架构与目标进程不匹配";
            result.ErrorCode = ERROR_BAD_EXE_FORMAT;
            return result;
        }
        
        // 使用匹配的DLL
        return InjectDllInternal(target, compatibleDllPath, method);
    }
    
    // 架构匹配，直接注入
    return InjectDllInternal(target, dllPath, method);
}
```

## 10. 总结

无线远程注入模块是Windows安全防护系统中的高级功能组件，通过网络连接实现对远程计算机进程的代码注入，为系统提供了远程安全监控和响应能力。该模块采用命令模式、策略模式和观察者模式等设计模式，实现了灵活、可扩展、安全的远程注入框架。

在实现无线远程注入时，需要特别注意以下几点：

1. **安全性**：确保通信加密、身份验证和权限控制，防止未授权访问
2. **稳定性**：实现错误恢复机制，确保注入失败不会导致远程系统不稳定
3. **兼容性**：考虑不同Windows版本和系统架构的差异，确保在各种环境下正常工作
4. **性能**：优化连接管理和注入操作，提高系统响应速度和资源利用率
5. **可扩展性**：通过设计模式和接口设计，支持新增注入技术和功能扩展

通过合理设计和实现无线远程注入模块，可以为Windows安全防护系统提供强大的远程管理和防护能力，满足企业级安全管理、远程安全审计、分布式安全防护等场景的需求。