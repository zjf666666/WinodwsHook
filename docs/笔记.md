# 笔记

### 一、指针与引用

在使用dynamic_cast强转引用和指针时，会出现完全不同的两种结果

1. 强转引用，在校验时如果发现无法强转，会抛出异常，如果没有try catch会导致程序崩溃

2. 强转指针，在校验时如果发现无法强转，会返回空指针，可以由用户自己根据返回值判断

```cpp
// 例如 
class A 
{
public:
    virtual ~A() {}
};
class B : public A {};
class C : public A {};
A* a = new B();
C* c = dynamic_cast<C*>(a) // 尝试将B类型指针转换为C类型指针，此时会返回nullptr指针

B b;
A& a = b;
C& c = dynamic_cast<C&>(a) // 尝试将B类型引用转换为C类型引用，此时会抛出异常
```

### 二、封装

​	站在用户角度考虑这个程序，以监控某程序的文件操作为例，客户端代码

```cpp
#include "watch.h"
int main()
{
		watch(pid, path, name, type);
		return 1;
}
```

​	我认为watch中应该不应该暴露任何实现相关的内容，相当于这个watch只有一个h文件，具体实现被封装在dll或者一些别的文件中，用户无法查看，这个watch.h中只有接口声明。

​	这个操作对于集成产品来说，是合理的，紧接着，我就产生了，watch在调用hook类时也应该这样做的想法

​	我当即否定了这个想法，这是属于集成文件的内部实现，而不是又集成了另一个库，他们的实现应该是可见的。

​	接着我开始考虑另一个问题：进入到watch函数后，正常来说，我需要配置参数，然后传入hook，后续的细节不再是watch需要关注的，那么就应该是watch函数不可见的。我认为所谓的不可见意思就是我引用了你的头文件，这个头文件包含它的实现都应该与Hook具体实现无关，不能暴露任何细节。

​	这里就出问题了，我的Hook使用工厂模式，提供一个create函数，根据传入的Hook类型，生成对应的Hook类。在create实现中需要调用具体的hook类，那不就从watch函数内找到了我的具体实现了吗？

​	我误解了不暴露细节的含义，不暴露细节实际上在代码中的体现就是依赖关系，只要我的依赖没有包含Hook实现相关的头文件，那就可以称为没有暴露细节了，头文件的具体实现是否包含具体实现与当前实现无关。

​	举个例子，watch.cpp、hookfactory.h、hookfactory.cpp是这样写的

```cpp
watch.cpp
#include "hookfactory.h"

void watch(DWORD pid, const std::string& path, const std::string& name, int type)
{
	IHook* hook = hookfactory::CreateHook(pid, path, name, type)
}

hookfactory.h
#include "IHook.h"
class hookfactory
{
public:
	static IHook* CreateHook();
};

hookfactory.cpp
#include "inlinehook.h"
#include "iathook.h"
IHook* CreateHook(DWORD pid, const std::string& path, const std::string& name, int type)
{
	...
}
```

​	我误以为hookfactory.cpp中出现了inlinehook.h和iathook.h就相当于watch也依赖了具体实现，但其实这是错误的，hookfactory.cpp属于工厂的内部实现，已经与watch的业务无关了，watch可见的仅有hookfactory.h中的内容，也只依赖于CreateHook函数，只要CreateHook入参、出参不变，就不需要watch做出改动。这就实现了我们需要的效果——底层细节改动不影响业务层。也是抽象类的作用——依赖倒转。让hookfactory.h可以不直接依赖于具体实现。

​	实际上private、protected也是封装的一部分，private就是私有，protected则是受保护的，两者在外部均不可直接使用，所以有些函数在h文件中出现也没关系，因为对于外部来说，实际上是不可见的，只是开发时这些都能看见会让我们产生一种这些函数暴露了的感觉。

### 三、前向声明+指针

#### 1. 问题

​	在HookEngine类中，私有成员变量m_mapHookInfo使用到了Hookinfo类型，这个类型仅在HookEngine类内部使用，按照正常逻辑，这里必须包含Hookinfo头文件，这就导致外部引用HookEngine类时，可以知道HookInfo的细节，但实际上这对外部是无用的。此外，这种做法还违背了开闭原则，在HookInfo被修改后，外部调用方也需要重新编译。

#### 2. 解决方案

​	使用前向声明+指针的形式，仅在HookEngine中声明HookInfo类，而不包含头文件，在m_mapHookInfo中使用HookInfo类指针。使用指针是因为指针不需要立即初始化，如果使用对象，编译器在编译时必须知道类大小、类的构造函数和析构函数，这意味着必须知道类的实现方式。为了避免内存泄漏，建议使用智能指针。

### 四、智能指针

#### 1. 场景一（该场景在代码实现中已修改，仅作为一个例子使用）

​	在实现HookEngine时，需要在成员变量中添加观察者数组std::vector<IHookObserver*>，为了确保IHookObserver对象指针稳定释放，考虑使用智能指针。

##### 1.1 unique_ptr

​	unique_ptr是独占式智能指针，使用之前，需要确认使用的地方所拥有的是否是“唯一所有权”，也就是除了使用地方之外，不会再有人持有这个指针

​	根据unique_ptr的含义，这里不可以使用它作为vector内的数据，即不能写成std::vector\<std::unique_ptr\<IHookObserver>>。这是因为IHookObserver的所有者是调用方，调用RegisterObserver传入，如果这里使用了unique_ptr，意味着调用方要舍弃传入的观察者对象。这是错误的，因为调用方还需要使用这个对象执行别的操作，如IPC发送消息，记录Hook函数信息等，HookEngine不是唯一所有者，无法使用unique_ptr。即使使用了也会面临二次析构的问题，外部无法调用HookEngine释放unique_ptr，而外部如果析构了，HookEngine也无法感知，就会出现二次析构的问题。

##### 1.2 share_ptr

​	share_ptr是共享智能指针，当所有使用者全部析构了，才能把指针析构，它的主要作用是延长对象的生命周期。

​	IHookObserver的生命周期应该是由调用方（注入的dll）控制的，如果使用共享指针，会导致IHookObserver的生命周期混乱，例如，dll卸载时， HookEngine 的shared_ptr仍持有引用，导致观察者无法释放（内存泄漏）；

##### 1.3 weak_ptr

​	（说实话，我根本没想到还能用这个指针，如果你也是，且看到了这里，恭喜你，今天学到了）

​	weak_ptr在八股文里告诉我们，这个指针的主要作用是解决share_ptr出现的循环引用问题。但这个指针的本质是“无所有权的观察”，听着就很契合观察者模式

​	事实也确实如此，使用weak_ptr，可以解决share_ptr导致的生命周期的问题。在调用方使用share_ptr，在HookEngine内使用weak_ptr接收。了解过weak_ptr的都知道，weak_ptr不会增加share_ptr的引用计数，也就不会影响调用方原先的生命周期。在HookEngine内部weak_ptr可以通过lock()函数检测share_ptr是否存活（使用lock函数临时转换为share_ptr，如果share_ptr已销毁，会返回空），存活才能使用

​	但是weak_ptr也存在问题，首先必须配合share_ptr才能使用；其次，每次都需要先检测share_ptr是否存活，存在性能开销；最后weak_ptr依旧无法自动释放，需要外部手动释放（外部share_ptr释放是不会影响到weak_ptr的）

##### 1.4 解决方案

​	最终选择了最朴素的方式，保留了std::vector<IHookObserver*>的方式。因为能用的智能指针也都需要手动释放，且存在生命周期混乱和性能开销问题，那不如使用最原始的方式，严格保证释放逻辑来避免内存泄露。

#### 2. 场景二

​	在实现前后端交互逻辑时，使用了`class ClientSession : public std::enable_shared_from_this<ClientSession> `的继承方式。这里涉及到share_ptr的一个使用缺陷，share_ptr在管理裸指针时，无法识别到已有计数器，导致出现反复析构的问题。

​	所谓的裸指针是指，直接new生成的指针，例如int* n = new int(); A* a = new A();等，不要使用裸指针重复给智能指针赋值，会导致所有的智能指针都以为只有自己一个所有者，析构时反复析构。

##### 2.1 实际应用场景

​	在网络编程中，经常会出现异步操作，这就要求类对象的生命周期延长到所有异步操作结束之后，因此往往会使用share_ptr进行类对象管理。在类内，又往往需要将自身传递给异步函数作为参数，此时，如果直接传this指针，就相当于使用裸指针给share_ptr赋值，此时引用计数只有1（正常应该是2，1个是this本身，另一个是传给异步操作的参数）。使用```enable_shared_from_this```，在代码中使用```auto self = shared_from_this(); // 从当前类生成一个share_ptr```，然后将self传入异步函数就能保证引用计数正常。

#### 3. 总结

​	如果考虑使用智能指针，第一个考虑的问题是，使用方是否是指针的“所有者”，即指针的生命周期是否归自己管理，如果不是，那么能考虑的就只剩下weak_ptr了。如果是，下一步考虑，这个指针是否是我独有的，不允许任何别的类持有，且内部也仅允许有一份，如果是，那就选择unique_ptr，如果不是就选择share_ptr。

### 五、auto关键字

​	C++11之后将auto关键字重新定义为自动类型推导。正确使用auto关键字，能提升代码开发效率及可读性。例如一般的迭代器类型很长，可读性较差，使用auto可以减少这类代码

```cpp
// 使用auto前
std::map<std::string, std::string>::itertor iter = ...;
// 使用auto后
auto iter = ...;
```

​	使用auto关键字还可以减少代码修改

```cpp
// 使用auto前，需要修改定义+for循环
std::vector<int> vec = std::vector<int>{1, 2, 3};
for (int n : vec) {...}
// 使用auto后 仅需修改赋值内容即可
auto vec = std::vector<int>{1, 2, 3};
for (auto n : vec) {...}
```

​	此外，lambda表达式必须使用auto作为返回值类型

​	一般而言，函数返回值，全局变量或类的成员变量，初始化表达式的类型不明确时，不建议使用auto关键

### 五、RAII

​	



