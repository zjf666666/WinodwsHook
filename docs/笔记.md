# 笔记

### 一、指针与引用

        在使用dynamic_cast强转引用和指针时，会出现完全不同的两种结果

        1. 强转引用，在校验时如果发现无法强转，会抛出异常，如果没有try catch会导致程序崩溃

        2. 强转指针，在校验时如果发现无法强转，会返回空指针，可以由用户自己根据返回值判断

```cpp
例如 
class A 
{
public:
    virtual ~A() {}
};
class B : public A {};
class C : public A {};
A* a = new B();
C* c = dynamic_cast<C*>(a) // 尝试将B类型指针转换为C类型指针，此时会返回nullptr指针

B b;
A& a = b;
C& c = dynamic_cast<C&>(a) // 尝试将B类型引用转换为C类型引用，此时会抛出异常
```

### 二、封装

         站在用户角度考虑这个程序，以监控某程序的文件操作为例，客户端代码

```cpp
#include "watch.h"
int main()
{
		watch(pid, path, name, type);
		return 1;
}
```

        我认为watch中应该不应该暴露任何实现相关的内容，相当于这个watch只有一个.h文件，具体实现被封装在dll或者一些别的文件中，用户无法查看，这个watch.h中只有接口声明。

        这个操作对于集成产品来说，是合理的，紧接着，我就产生了，watch在调用hook类时也应该这样做。

        我当即否定了这个想法，这是属于集成文件的内部实现，而不是又集成了另一个库，他们的实现应该是可见的。

        接着我开始考虑另一个问题：进入到watch函数后，正常来说，我需要配置参数，然后传入hook，后续的细节不再是watch需要关注的，那么就应该是watch函数不可见的。我认为所谓的不可见意思就是我引用了你的头文件，这个头文件包含它的实现都应该与Hook具体实现无关，不能暴露任何细节。

        这里就出问题了，我的Hook使用工厂模式，提供一个create函数，根据传入的Hook类型，生成对应的Hook类。在create实现中需要调用具体的hook类，那不就从watch函数内找到了我的具体实现了吗？

        我误解了不暴露细节的含义，不暴露细节实际上在代码中的体现就是依赖关系，只要我的依赖没有包含Hook实现相关的头文件，那就可以称为没有暴露细节了，头文件的具体实现是否包含具体实现与当前实现无关。

        举个例子，watch.cpp、hookfactory.h、hookfactory.cpp是这样写的

```cpp
watch.cpp
#include "hookfactory.h"

void watch(DWORD pid, const std::string& path, const std::string& name, int type)
{
		IHook* hook = hookfactory::CreateHook(pid, path, name, type)
}

hookfactory.h
#include "IHook.h"
class hookfactory
{
public:
		static IHook* CreateHook();
};

hookfactory.cpp
#include "inlinehook.h"
#include "iathook.h"
IHook* CreateHook(DWORD pid, const std::string& path, const std::string& name, int type)
{
		...
}
```

        我误以为hookfactory.cpp中出现了inlinehook.h和iathook.h就相当于watch也依赖了具体实现，但其实这是错误的，hookfactory.cpp属于工厂的内部实现，已经与watch的业务无关了，watch可见的仅有hookfactory.h中的内容，也只依赖于CreateHook函数，只要CreateHook入参、出参不变，就不需要watch做出改动。这就实现了我们需要的效果——底层细节改动不影响业务层。也是抽象类的作用——依赖倒转。让hookfactory.h可以不直接依赖于具体实现。
