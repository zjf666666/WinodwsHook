以x86为例 （x64仅覆盖长度不同）
1. 默认使用5字节跳转，使用16字节的数据存放
2. 将这16字节数据使用zydis库解析，发现第一条指令只有2字节
3. 继续解析，直到长度>=5，例如第二条指令是4字节，那么需要保存的数据长度就为6，将原函数的前6字节保存下来
4. 然后，重定向第一条指令数据，将它写到跳板函数中，这里可能长度会改变，但无需在意，只要保证内存够大即可，这里写完后，relocate函数会返回一个写入长度
5. 继续处理第二条指令（4字节），也有可能长度改变，也不需要关注，只要保证内存足够大即可，从跳板函数地址+前一个指令的长度开始继续写即可，然后返回第二个长度
6. 在跳板函数地址+前两个指令的长度的位置写入最后的jmp回原函数被覆盖之后的偏移地址即可
7. 使用5字节跳转+一个nop字节覆盖掉被hook的函数前6字节
8. 最后卸载时，将保存的6个字节还原，释放跳板函数内存，就ok了
在执行第7、8步时会出现多线程问题，如果正好有程序调用到这些指令了，此时覆盖会导致程序崩溃