# 指令解析与重定位库选型与集成速查（Zydis 优先）

本文档面向“我要自己实现 Inline Hook，但指令解析与重定位要走最快工程路线”的目标，按照 What / Why / How / Where 四个维度说明。

—

## What（这是什么）
- 目标：在 x64（兼顾 x86）上，稳定实现“入口指令解析 → 选择可重定位的最小 N 字节 → 对相对控制转移与 RIP-relative 访问做改写 → 生成 trampoline 并在原址植入跳转”的完整链路。
- 范围：
  - 指令解码：长度、操作数、是否相对（rel8/rel32）、是否 RIP-relative 内存寻址。
  - 指令重定位：计算绝对目标地址，按模板重编码为等价序列。
  - 输出：trampoline 字节序列与原址跳转序列。
- 不做：本指南不提供现成 Hook 框架，只聚焦“指令解码/重定位”的底座集成与用法。

—

## Why（为什么选 Zydis）
- 时间成本最小：
  - HDE 虽然集成最轻，但 x64 上你需要自己覆盖 RIP-relative 内存与多类相对分支的改写，调试成本高且长尾不可控。
  - Zydis 提供完整元数据与辅助计算（如相对目标、RIP 绝对地址、操作数编码信息），并有编码器可直接重编码，能显著降低你在 x64 上的实现与调试时间。
- 工程化与可扩展：
  - 便于后续扩展更复杂的指令与模板（SSE/AVX 变体、罕见分支指令）。
  - 面试表达利好：能说明“工业级解码器 + 自动重编码”的方案选择与权衡。

—

## How（如何集成与使用）

### 1) 获取依赖
- 方案 A：使用 vcpkg（推荐）
  - x64：`vcpkg install zydis:x64-windows`
  - 需要编码器（可选）：Zydis 自带 Encoder；若选择通用汇编器，可用 `AsmJit:x64-windows`
  - 若需 x86 同构测试：`vcpkg install zydis:x86-windows`
- 方案 B：源码集成
  - 从官方仓库获取 Zydis 源码，加入你的解决方案，配置包含目录与编译选项。

提示：保持 Debug/Release、x86/x64 四套配置一致；优先使用静态链接以简化部署。

### 2) 工程配置要点
- 包含目录与库目录：按 vcpkg 或源码路径添加。
- 运行时库一致性：确保与工程其余模块（尤其是 DLL）一致，避免 CRT 冲突。
- 命名空间与头文件：`#include <Zydis/Zydis.h>`（具体以安装路径为准）。

### 3) 最小工作流（解码 → 判定 → 改写 → 重编码）
- 初始化解码器：`ZydisDecoderInit`（x64 模式或 x86 模式）。
- 逐条解码入口指令：使用 `ZydisDecoderDecodeBuffer`，累加 `instruction.length`，直到达到“原址跳转序列”的所需字节（x64 常用 `mov rax, imm64; jmp rax` 需要 12 字节）。
- 判定与计算：
  - 相对控制转移（CALL/JMP/Jcc rel8/rel32、LOOP/JECXZ/JRCXZ 等）：
    - 使用 Zydis 的操作数信息判断是否相对，计算绝对目标（可用 `ZydisCalcAbsoluteAddress`）。
    - 改写模板（x64）：
      - `jmp rel*` → `mov rax, imm64; jmp rax`
      - `call rel*` → `mov rax, imm64; call rax`
      - `jcc rel*` → `jcc skip; mov rax, imm64; jmp rax; skip:`
  - RIP-relative 内存寻址（x64 的 `[rip + disp32]`）：
    - 计算绝对地址，改写为对绝对地址的等价访问（直接绝对内存或“装入寄存器再间接访问”，视原指令而定）。
  - 其他非相对类：原样拷贝（或用 Encoder 重新编码，保持语义一致）。
- 重编码：
  - 选项 1：Zydis Encoder（直接按目标操作数/寻址信息生成机器码）。
  - 选项 2：AsmJit（通用 JIT 汇编器，便于快速拼装模板序列）。
- 输出到 trampoline：
  - 将改写后的字节顺序写入 trampoline；末尾追加跳回原函数剩余指令的绝对跳转（x64 通常 `mov rax, imm64; jmp rax`）。
- 原址安装跳转：
  - 覆盖原函数入口 N 字节，写入跳向你的 Hook 的跳转序列（x64 建议统一使用 `mov rax, imm64; jmp rax` 以规避 ±2GB 约束）。

### 4) 测试用例 Checklist（最少覆盖）
- 无相对：`push rbp; mov rbp, rsp` 开头一组。
- 相对调用：`call rel32` 指向同模块函数。
- 短跳：`jcc rel8`（如 `jne +5`）。
- RIP-relative 跳转表：`jmp [rip+disp32]`（延迟绑定/转发表常见）。
- RIP-relative 数据访问：`mov rax, [rip+disp32]`。
- 验证点：返回值与 GetLastError 在“原地执行 vs trampoline 执行”完全一致；在 Win10/Win11、普通进程与 explorer 进程中各跑一遍。

### 5) 常见坑位速记
- 位宽匹配：x64 进程注入 x64 DLL；WOW64 不要串位宽。
- 页面保护：修改代码段前后正确设置/恢复保护页（执行-写入同步）。
- 原址 N 字节：确保不截断一条指令；N 需覆盖完整指令序列直到能放下你的跳转序列。
- 转发导出：Hook kernel32 API 时注意其转发到 KernelBase 的情形，目标选址要清楚（但对重定位过程无差别）。
- LastError 透明：调用原函数后保存并在返回前恢复。

—

## Where（放在哪里用）
- 代码位置建议：
  - 解析与重定位逻辑集中在“指令层”模块，便于单测与复用。
  - 可落在以下文件所对应的模块中：
    - <mcfile name="InstructionParser.cpp" path="e:\WinodwsHook\WindowsSecurityGuard\HookEngine\InstructionParser.cpp"></mcfile>
    - <mcfile name="InstructionRelocator.cpp" path="e:\WinodwsHook\WindowsSecurityGuard\HookEngine\InstructionRelocator.cpp"></mcfile>
    - <mcfile name="InstructionParser.h" path="e:\WinodwsHook\WindowsSecurityGuard\HookEngine\InstructionParser.h"></mcfile>
    - <mcfile name="InstructionRelocator.h" path="e:\WinodwsHook\WindowsSecurityGuard\HookEngine\InstructionRelocator.h"></mcfile>
- 第三方依赖放置：
  - 推荐使用 vcpkg 统一管理；若走源码，引入到 `third_party/zydis/`（新建目录）并在工程中配置包含与库目录。
- 调用时机：
  - 在安装 Inline Hook 前，对目标函数入口做“解码与可重定位性检查”；
  - 在构建 trampoline 阶段对“相对/ RIP-relative”指令做改写与重编码；
  - 最后覆盖原址并写入跳转到你的 Hook 函数。

—

## 附：最小集成步骤清单（你可以逐条打勾）
1) 引入 Zydis（vcpkg 或源码），四套配置均能编译。
2) 写一个函数：给定入口地址，使用 Zydis 逐条解码并累加长度到 ≥12（x64 跳板模板）。
3) 在循环中判定是否相对分支或 RIP-relative；能算出绝对目标地址。
4) 对需要改写的指令，使用 Encoder/AsmJit 生成等价序列；其他指令保留原义。
5) 将生成的字节写入 trampoline，并在末尾写回跳到原函数剩余部分的跳转。
6) 原址覆盖 N 字节并写入跳向你的 Hook 的跳转序列。
7) 用“相对调用、短跳、RIP-relative（跳转表/数据访问）”样例验证一次性通过。

—

如果你决定采用 HDE 作为备选，请把范围限制在“仅处理 CALL/JMP/Jcc 的 rel* 改写；遇到 RIP-relative 先放弃”这一最小闭环，等 x64 基础稳定后再扩展。这样能控制时间与风险。