# 业务需求、业务逻辑、技术实现

​	在实现这个项目过程中反反复复的思考了什么是业务需求、什么是业务逻辑、什么是技术实现。虽然还是没有完全想明白，但无论如何，总归有所收获，在这里写下我的见解，希望能给大家一些启发，也欢迎大家指正错误或不足之处。

## 一、业务需求

### 1. 业务需求怎么来的

​	业务需求的来源分为两种：“**订单式业务**”和“**产品式业务**”。甲方提出自己的需求，乙方做一个满足甲方需求的软件，这就是订单式业务；通过市场调研，发现了用户需要某种功能的产品，然后开发，这就是产品式业务。以当前项目为例，这是我自己提出了一个需求，而不是调研市场后得到的需求，所以是订单式业务。

### 2. 业务需求是什么

​	这个问题是我思考的最多的。在我的上一家公司中，需求都是来自于产品经理或者研发经理，他们告诉我们要做什么，我们就做什么，我一直以为他们给我们的需求就是业务需求。在实现这个项目中，我发现不对，业务需求大概率是模糊的，且是用户视角的，而产品经理和研发经理给到研发的需求已经是具体的，敲定了方案的，这完全就是两个概念。

​	举个例子，我这个项目的业务需求是什么？最模糊的回答就是windows安全防护软件，再具体一些，就是不允许我的电脑中病毒，即使中毒了也应该可以溯源；那么正常到开发手里的需求是什么呢？研发A——你去做进程监控驱动，要能监视windows所有的进程运行、研发B——你去做个文件API HOOK，把API的入参、出参、返回值都取出来。

​	很明显，到研发手里的活已经和业务无关了，研发不知道自己做这个到客户现场的实际使用场景，也不知道客户的具体需求，所以这实际上不是需求而是“功能”。产品经理+研发经理把业务需求拆分成了具体的功能，分配给了研发去实现。

​	显而易见，业务需求是“我为什么要做这件事”，功能是“我做了这件事”，他们之间的差距是少了一个“为什么”。

### 3. 不理解业务需求有什么后果

#### 3.1 “不好用”的产品

​	一般来说，不理解业务需求，不会导致产品“不可用”，只会导致产品“不好用”。

​	举一个很简单的例子，用户现场有一个ps1脚本的运行日志频繁上报，且调用方都是windows系统进程，一天一台机器上报几百万条，这导致日志界面全是这个日志，且查询速度越来越慢，影响到用户查询别的日志了，用户对这个功能表示不满意，要求修改。

​	这不小事一桩，查一下日志，看哪些系统进程调用了这个ps1文件，根据文件名+进程名过滤掉这个事件，1个小时不到就搞定了。

​	但是很快又不对了，用户在另一台电脑上发现这个日志还是存在，但是调用进程换成了另一批windows系统进程。

​	得，跟老子过不去是吧，一气之下把所有的windows进程名称全加进去了，这总没问题了吧。

​	很快，用户又反馈，有一台机器上出现了另一个名字的ps1脚本被系统进程频繁调用。

​	没辙，继续加吧。

​	几天后，用户电脑中病毒了，一看是因为过滤逻辑把病毒也给放过了，得，赔麻了。

​	这里有两个问题：1. 开了一个后门，完全违背了产品初衷——windows安全防护软件；2. 没有抓住用户痛点——过滤掉windows正常行为事件，不要上报，即使做不到全面覆盖，也应该找到这类事件的逻辑，完全过滤掉这类事件。

​	实现功能时应该服务于业务需求，而不是为了开发功能而开发，知道这个功能究竟要解决什么问题，才能知道使用什么方案实现。

#### 3.2  设计思想上出了问题

​	此外，不懂得业务需求还会导致过度设计、设计方向错误，还是举个例子。

​	客户是一名炼钢厂老板，需要给生产环境安装安全软件，防止遭受勒索病毒。

​	需求到研发了，安全软件吗，杀毒肯定得有吧，整个黑名单库+引擎，再来个实时监控，注册表不能落下，文件操作监控一下，进程也监控一下。

​	一天过去了，欸，怎么设计了个360出来？不对，我比他强，我没那么流氓，他们不装360肯定是因为360太流氓了，自己就像个病毒。

​	第二天，一合计，这开发少说得一年吧，还不算这个扫描引擎+黑名单库收集，客户一听，byebye。

​	赶忙挽留，半年半年（砍一些功能掉，合计合计，就先做个杀毒把），客户勉强答应了。

​	半年后，产品一上，各种误报拦截，频频停产。一看产品，你们做的什么玩意，还不如360，我们不装360就是因为误报太多了导致生成不正常。

​	最后，了解现场环境，基本所有电脑只会运行生产软件，且常年不断电，24小时生产。根据这个场景，只需要监控进程+软件白名单即可，根本不需要杀毒功能。

​	这个例子中，一开始出现了过度设计的问题（杀毒功能是完全不需要的），由于时间问题，选择砍掉一部分设计，砍错了方向，将进程部分逻辑砍掉，仅保留了杀毒功能，这就是设计方向错误。



## 二、业务逻辑和技术实现

​	在开发的时候，经常听到业务逻辑要和技术实现解耦。但是没有人告诉过我什么是业务逻辑什么是技术实现，他们之间的分界线是什么。这两者其实是息息相关却又在开发中必须区分的，因此放到一起讲

### 1. 最底层的业务逻辑和技术实现

​	调研后发现，可以使用inline Hook来实现这个功能。我们先研究了inline Hook技术，写下了一个inline Hook流程

- 获取目标函数地址

- 解析前N字节的指令

- 重定向这些指令

- 创建跳板函数，将重定向后的指令写入

- 保存原函数指令

- 计算偏移

- 更改指令，跳转地址为我们的hook函数

- 再加一些生命周期管理函数

  劈里啪啦一顿敲，2个小时搞定了，好了接下来怎么用呢？

- 先给一个初始化接口，把你要hook的模块、函数和要替换的函数地址告诉我

- 再给你一个安装接口，初始化好，安装上就行了

- 最后再给你一个卸载接口，不用了记得把我卸载了

  okok，拿着这三个接口不是洒洒水

- 自定义一个HOOK函数
- 在DllMain函数的DLL_PROCESS_ATTACH中调用初始化接口
- 再调用安装接口
- 最后在DLL_PROCESS_DETACH中调用卸载接口

​	经过这三步，一个可以inline hook就完成了，只需要将这个dll注入到目标进程，就完事了。

​	在这个例子中，谁是技术实现？很明显，第一步根据inline hook的流程实现这项技术就是技术实现，站在调用方，我们也往往称它为技术细节。第二步、第三步就属于业务逻辑，我使用你提供的接口，实现完整的业务逻辑——初始化、安装、卸载。

​	这里也涉及到一个很经典的开发原则——依赖倒转原则。未使用依赖倒转原则处理的代码实现逻辑是这样的

```c++
// inlineHook.h
class inlineHook{
public:
    void init(std::string module, std::string targetfunc, void* hookfunc);
    bool install();
    bool uninstall();
}

// dllmain.cpp
#include "inlineHook.h"
void myHook() {}
...
inlineHook hook;
hook.init("Kernel32.dll", "CreateFile", myHook);
hook.install();
...
hook.uninstall();
```

​	业务逻辑直接依赖于具体细节，当我们需要替换hook方式时，我们需要修改的内容为

- 增加一个Hook类
- 修改业务逻辑内的头文件引用、初始化、安装、卸载等逻辑，项目越大，这里修改的内容就越多，例如如果使用了这个技术100次就得改100个地方
- 重新编译dllmain+新增的Hook类

我们的业务逻辑也需要跟着一起修改。使用依赖倒转原则处理后的代码实现逻辑是这样的

```
// IHook.h
class inlineHook {
public:
/* 对于业务而言，我只需要知道三个操作，初始化、安装和卸载，抽象类是根据业务进程封装的，而不是技术 */
    virtual void init(std::string module, std::string targetfunc, void* hookfunc) = 0;
    virtual bool install() = 0;
    virtual bool uninstall() = 0;
}

// HookFactory
class HookFactory {
public:
	IHook* Create(int type);
}

// dllmain.cpp
#include "IHook.h"
#include "HookFactory.h"
void myHook() {}
...
int type = readConfig(); // 读取配置
IHook* hook = Create(type);
hook->init("Kernel32.dll", "CreateFile", myHook);
hook->install();
...
hook->uninstall();
```

​	使用抽象类+工厂模式，将inlinehook完全隐藏，增加一个配置读取操作，将业务选择逻辑与具体Hook解耦，当我们需要新增Hook类型是，我们需要修改的内容为

- 增加一个Hook类继承于抽象类
- 修改配置文件的默认配置
- 在HookFactory的create函数增加一个选择
- 编译HookFactory+新增的Hook类

乍一看似乎倒转之后还多了一步，但实际上倒转之后减少了大量的工作量，原因在下一个例子中讲述。

### 2. 通信层传输格式的业务逻辑和技术实现

​	当前项目采用C/S架构，客户端与服务器端需要实现进程间通信，通信内容需要有一定的格式，一般都会使用json作为格式协议。这里显然我不可能自己实现一个json库，因此考虑使用别人封装好的库。这里别人封装好的库就是技术实现，我使用这个库的所有逻辑都算业务逻辑，例如，客户端把用户输入组装成json，后端解析json，这些都是业务逻辑。

​	在使用库时，我想到了一件事，我以前开发的软件，基本上所有的模块都用到了json库，而后来这个json库被发现存在漏洞，只有两种解决方案：换库或者修改老的库，把这个漏洞解决了。第一种，至少得修改上万行代码，而且得一点点找；第二种，不知道改完会不会引入新的问题。两种方法的成本都很高，但无论怎么看都是第一种方式最保险。

​	为了规避这个问题，我使用了DTO(**Data Transfer Object，数据传输对象**)对json库进行了封装。DTO提供了两个函数——ToJson和FromJson，客户端发送请求时，给DTO对象赋值，然后通过Json库转换为json的字符串格式，服务器端收到后，先通过FromJson解析数据，再将DTO类分发下去。

​	这种方式避免了所有模块都直接依赖于json库导致修改json库代价超高的问题。











