# Logger 实现说明文档

## 1. 概述

`Logger` 是 Windows 安全防护系统中的核心日志组件，采用单例模式设计，提供统一的日志记录服务。该组件负责系统各模块的日志管理，支持多级别日志记录、文件轮转和性能统计等功能，是系统诊断和问题排查的重要工具。

## 2. 设计模式

### 单例模式

`Logger` 类采用单例模式实现，确保整个系统中只有一个日志实例，避免多实例导致的文件冲突和资源浪费。

**实现要点**：
1. 私有化构造函数和析构函数
2. 禁用拷贝构造和赋值操作
3. 提供全局访问点 `GetInstance()`
4. 线程安全的单例实现

## 3. 函数实现说明

### 3.1 GetInstance 获取单例实例

```cpp
static Logger& GetInstance();
```

**使用场景**：
- 系统各模块需要记录日志时，通过此函数获取 Logger 的唯一实例
- 配置管理模块需要更新日志设置时
- 系统初始化时获取实例并进行初始化

**实现思路**：
1. 使用局部静态变量确保线程安全（C++11及以上）
2. 或使用双检锁（Double-Check Locking）模式确保线程安全
3. 返回静态实例的引用

**注意事项**：
- 需要考虑多线程环境下的安全性
- 在 C++11 之前，需要使用互斥锁保护实例创建
- 在 Windows 环境中，可以考虑使用 `std::call_once` 或 `InitOnceExecuteOnce` API

### 3.2 Initialize 初始化日志系统

```cpp
bool Initialize(const std::wstring& logPath, LogLevel minLevel = LogLevel::Info, const std::wstring& logFileName = L"SecurityGuard.log");
```

**使用场景**：
- 系统启动时初始化日志组件
- 配置更新后重新初始化日志系统
- 日志路径或级别需要动态调整时
- 自定义日志文件名

**实现思路**：
1. 验证日志路径的有效性，必要时创建目录
2. 设置最小日志级别
3. 打开日志文件，准备写入
4. 初始化内部状态（如缓冲区、计数器等）
5. 记录初始化成功的信息

**注意事项**：
- 处理路径不存在或无写入权限的情况
- 考虑日志文件命名规则（如包含日期、进程ID等）
- 初始化失败时提供合理的错误信息
- 防止重复初始化导致的资源泄漏

### 3.3 Debug/Info/Warning/Error/Fatal 不同级别日志

```cpp
void Debug(std::wstring format, ...);
void Info(std::wstring format, ...);
void Warning(std::wstring format, ...);
void Error(std::wstring format, ...);
void Fatal(std::wstring format, ...);
```

**使用场景**：
- **Debug**：记录详细的调试信息，仅在开发或问题排查时启用
- **Info**：记录正常操作信息，如系统启动、功能初始化成功等
- **Warning**：记录潜在问题或异常情况，但不影响系统正常运行
- **Error**：记录错误信息，表示功能无法正常完成
- **Fatal**：记录严重错误，可能导致系统崩溃或无法继续运行

**实现思路**：
1. 检查当前日志级别是否需要记录该消息
2. 调用内部 `WriteLog` 方法，传入对应的日志级别和消息
3. 对于 Fatal 级别，可能需要额外处理（如立即刷新缓冲区、触发告警等）

**注意事项**：
- 确保日志格式一致，包含时间戳、级别、线程ID等信息
- 考虑性能影响，特别是 Debug 级别的日志
- 处理特殊字符和长消息
- 考虑国际化和编码问题

### 3.4 SetLogLevel 设置日志级别

```cpp
void SetLogLevel(LogLevel level);
```

**使用场景**：
- 根据配置文件动态调整日志级别
- 问题排查时临时提高日志级别获取更多信息
- 生产环境中降低日志级别减少磁盘占用

**实现思路**：
1. 验证输入级别的有效性
2. 更新内部日志级别设置
3. 记录日志级别变更信息

**注意事项**：
- 考虑多线程环境下的并发访问
- 日志级别变更可能需要记录到日志文件中
- 可以考虑提供临时更改日志级别的功能（如在一段时间后自动恢复）

<!-- 注意：当前代码中未实现此函数 -->
### 3.5 Flush 强制刷新日志缓冲区

```cpp
// 注意：此函数在当前代码中未实现
void Flush();
```

**使用场景**：
- 确保关键日志立即写入磁盘
- 系统关闭前确保所有日志都已持久化
- 日志查看工具需要实时获取最新日志

**实现思路**：
1. 获取内部文件流的互斥锁
2. 调用文件流的 `flush()` 方法或Windows API的FlushFileBuffers
3. 释放互斥锁

**注意事项**：
- 频繁调用会影响性能，应谨慎使用
- 在记录关键操作或错误后应考虑调用此方法
- 系统崩溃前应尽可能调用此方法保存日志

<!-- 注意：当前代码中未实现此函数 -->
### 3.6 RotateLogFile 日志文件轮转

```cpp
// 注意：此函数在当前代码中未实现
void RotateLogFile();
```

**使用场景**：
- 日志文件达到预设大小时自动轮转
- 按时间周期（如每天、每周）轮转日志文件
- 手动触发日志轮转（如系统维护前）

**实现思路**：
1. 关闭当前日志文件
2. 根据命名规则重命名或移动当前日志文件
3. 创建新的日志文件
4. 可选：压缩或归档旧日志文件
5. 可选：删除过期的日志文件

**注意事项**：
- 确保轮转过程中不丢失日志
- 处理文件操作可能的异常情况
- 考虑多线程环境下的安全性
- 设计合理的日志文件命名和归档策略

### 3.7 WriteLog 内部写日志方法

```cpp
void WriteLog(LogLevel level, const WCHAR* format, va_list args);
```

**使用场景**：
- 内部使用，被各级别日志方法调用
- 统一处理日志格式化和写入逻辑

**实现思路**：
1. 检查日志级别是否需要记录
2. 格式化日志消息（添加时间戳、级别、线程ID等）
3. 获取文件操作的互斥锁
4. 写入日志文件
5. 检查是否需要刷新缓冲区
6. 检查是否需要轮转日志文件
7. 释放互斥锁

**注意事项**：
- 确保线程安全
- 处理文件写入错误
- 优化写入性能，考虑使用缓冲区
- 格式化日志时注意性能和可读性的平衡

## 4. 性能优化建议

1. **使用缓冲区**：避免频繁的小规模写入操作
2. **异步日志**：将日志写入操作放入单独的线程，避免阻塞业务逻辑
3. **批量写入**：收集多条日志后一次性写入
4. **日志级别过滤**：在源头过滤不需要的日志级别，减少字符串处理
5. **预分配缓冲区**：为格式化日志消息预分配足够的缓冲区
6. **减少锁竞争**：优化互斥锁的使用范围和粒度
7. **文件操作优化**：使用合适的文件打开模式和缓冲设置

## 5. 线程安全性

`Logger` 类需要在多线程环境下安全工作，应考虑以下几点：

1. **单例实现的线程安全**：确保 `GetInstance()` 在多线程环境下正确工作
2. **文件操作的互斥保护**：使用互斥锁保护文件写入操作
3. **状态变更的原子性**：如日志级别变更、文件轮转等操作需要保证原子性
4. **避免死锁**：合理设计锁的获取顺序，避免嵌套锁导致的死锁
5. **考虑使用读写锁**：对于读多写少的操作（如获取日志级别）可以使用读写锁提高并发性

## 6. 错误处理策略

日志组件本身的错误不应影响主系统运行，建议采用以下策略：

1. **降级处理**：当无法写入日志文件时，尝试写入备用位置或使用系统日志
2. **静默失败**：日志操作失败不应抛出异常，而是静默失败并尝试恢复
3. **自我诊断**：记录日志组件自身的错误状态，便于问题排查
4. **重试机制**：对于临时性错误（如磁盘满），实现重试机制
5. **容错设计**：在极端情况下（如所有日志路径都无法写入），提供最小功能保证

## 7. 扩展建议

1. **多目标输出**：支持同时输出到文件、控制台、网络等多个目标
2. **日志过滤器**：基于内容、来源等条件过滤日志
3. **结构化日志**：支持JSON等结构化格式，便于日志分析
4. **日志分类**：支持按模块或功能分类记录到不同文件
5. **远程日志**：支持发送关键日志到远程服务器
6. **性能计数器**：集成性能监控功能，记录关键操作的执行时间
7. **日志查询接口**：提供程序化的日志查询和分析能力

## 8. 测试建议

为确保 `Logger` 类的可靠性，建议进行以下测试：

1. **功能测试**：验证各级别日志记录功能
2. **性能测试**：测试高频日志记录的性能表现
3. **并发测试**：多线程环境下的稳定性测试
4. **异常测试**：磁盘满、权限不足等异常情况的处理
5. **长时间运行测试**：验证长期运行下的稳定性和资源使用
6. **文件轮转测试**：验证日志轮转功能的正确性

## 9. 注释规范

按照项目文档中定义的注释规范，所有 `Logger` 类的函数都应该有详细的注释，包括：

```cpp
/**
 * @brief 简要描述函数功能
 * @param [IN/OUT] 参数名 参数详细说明
 * @return 返回值说明
 * @exception 可能抛出的异常说明（如适用）
 * @note 其他需要说明的事项（如适用）
 */
```

例如，对于 `SetLogLevel` 函数：

```cpp
/**
 * @brief 设置日志记录的最低级别
 * @param [IN] level 新的日志级别，低于此级别的日志将不会被记录
 * @return void
 * @note 此设置立即生效，影响后续所有日志记录操作
 */
void SetLogLevel(LogLevel level);
```

## 10. 使用示例

```cpp
// 获取Logger实例并初始化
Logger::GetInstance().Initialize(L"C:\\Logs\\SecurityGuard", LogLevel::Debug);

// 记录不同级别的日志
Logger::GetInstance().Info(L"系统启动成功");
Logger::GetInstance().Warning(L"配置文件格式不规范，使用默认配置");
Logger::GetInstance().Error(L"无法连接到更新服务器，错误码: %d", GetLastError());

// 动态调整日志级别
Logger::GetInstance().SetLogLevel(LogLevel::Warning);

// 注意：以下功能在当前代码中未实现
// // 在关键操作后刷新日志
// Logger::GetInstance().Flush();
// 
// // 手动触发日志轮转
// Logger::GetInstance().RotateLogFile();
```

## 11. 安全注意事项

1. **敏感信息保护**：避免记录密码、密钥等敏感信息
2. **日志注入防护**：处理日志内容中可能的注入字符
3. **日志文件权限**：确保日志文件具有适当的访问权限
4. **日志加密**：考虑对包含敏感信息的日志进行加密
5. **日志完整性**：防止日志被未授权修改或删除
6. **资源限制**：防止日志占用过多系统资源（如磁盘空间）

通过合理实现这些功能和注意事项，`Logger` 类将成为 Windows 安全防护系统中强大而可靠的日志组件，为系统运行监控和问题诊断提供有力支持。