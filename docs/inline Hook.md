# inline Hook

### 一、简介

        修改原始函数的入口指令，使其跳转到另一个函数，这就是inlineHook的核心逻辑，也是hook的基本含义：“劫持”某个函数。

        inlineHook可以用于监控特定软件的行为，例如，我们可以hook CreateFile函数来实现对特定程序的文件操作。

         inlineHook允许我们在不修改原程序的情况下改变函数行为，或监控某些函数获取信息。

         inlineHook实现流程为：获取目标函数地址->解析目标函数首部指令->重定向指令->计算跳板函数到覆盖指令之后的偏移->重定向指令+跳转指令写入跳板函数->保存原函数需要覆盖的指令内容->计算原函数到HOOK函数的偏移(x86)或使用原函数地址(x64)->使用跳转指令覆盖原函数首部指令

         inlineHook触发流程：注入dll的进程调用目标函数->执行目标函数首部指令->进入HOOK函数->执行HOOK函数的操作->调用跳板函数->执行原函数被覆盖的指令->执行跳转函数，回到原函数被覆盖指令的后一条指令->执行原函数

         inlineHook的实现难点主要在于指令解析和重定向，在x86架构中使用5字节跳转，覆盖5字节就可以涵盖绝大多数场景，但是，x64架构无法再使用这种简单的方式来操作，首先x64引入了rip指令，绝大多数x64进程的函数首部指令都使用了rip，因此指令解析+重定向操作变成了必须操作；其次，x64架构的寻址范围从x86的$2^{32}$次变成了$2^{64}$次，4字节偏移量无法完全覆盖，需要使用别的指令来实现，例如mov rax, imm64等指令实现，这导致需要覆盖的指令变长，需要解析的指令从1条变成了无法估计的数，大大增加了解析与重定向的复杂度

### 二、x86实现（5字节跳转）

         1. 使用GetProcAddress获取目标函数地址

         2. 申请一块可读可写的内存（此时dll已经注入，所以申请的内存就是在当期进程空间内，正常来说10字节内存就能覆盖大部分使用场景）

         3. 解析指令，判断指令中是否为特殊指令，如间接跳转、条件跳转等

         4. 重定向指令，如间接跳转，需要根据申请内存的地址重新计算偏移值，确保执行跳板函数时能正确命中原函数期望执行的目标地址非特殊指令，保留原函数指令即可

         5. 将处理好后的指令写入跳板函数尾部

         6. 如果指令长度小于5，重复执行3、4、5步骤，直到解析的指令长度超过5（关键步骤，我们覆盖的长度是5，如果解析指令小于5，意味着有一部分原函数指令不会被执行了，可能导致严重且无法预知的错误）

         7. 计算跳板函数跳转回原函数下一条指令的偏移量，生成jmp/call指令，在跳板函数尾部写入

         8. 根据解析的指令长度，保存对应长度的原函数指令

         9. 计算HOOK函数与原函数的地址偏移，生成5字节jmp指令，如果覆盖指令长于5，补nop到与覆盖指令长度相同

         10. 将jmp指令覆盖原函数的首部指令

         11. 卸载时将保存的原函数指令写回原函数首部即可

### 三、x64实现

         流程与x86一致，在实现中需要注意的是

         1. 解析的指令长度需要根据你最后的覆盖指令长度来判断，一般考虑使用REX.W->MOV RAX, imm64->JMP RAX实现，长度为12

         2. x64引入了rip指令，且非常常见，各类指令中均可能出现（与指令类型无关，跳转、加减、移动等都可能出现这个指令），需要特殊处理

### 四、调试方式

         inlineHook实际上执行的操作并不多，调试时，只要理清楚各个内存地址、偏移之间的关系，基本上可以很快定位出问题原因。

         基本调试手段如下（我是使用的vs2022，以vs2022为例说明）：

         1. 先写一个简单的程序，这个程序包含两个操作——LoadLibrary加载注入dll、调用目标函数

         2. 在dll项目中，属性->配置属性->调试->命令，输入进程路径（相当于运行dll项目是，先运行exe程序加载dll）

         3. 在安装hook前，记录原函数地址，打开反汇编，输入原函数地址，记录原函数首部指令内容（尽量多记一点，一般来说最长不会超过16字节）

         4. 指令解析+重定向执行完毕后，找到跳板函数的反汇编，记录跳板函数反汇编内容（这里的长度一般来说重定向的时候都计算了，根据这个值来记录）

         5. 安装完成后，再次查看原函数地址，记录首部指令内容（x86 5位，x64 12位）

         6. 根据记录的这些指令，计算是否存在错误内容

         如果使用windbg可以使用附加进程的方式调试

### 五、调试案例

         问题1：在调试的时候，运行dll所在项目，高频率但非必现的出现0x00007FF9FE435DF4 处有未经处理的异常(在 test_exe.exe 中): 0xC0000005: 执行位置 0x00007FF9FE435DF4 时发生访问冲突。崩溃发生在目标函数执行处。

         调试过程：

         1. 查看0x00007FF9FE435DF4地址反汇编内容，发现均为?? ??信息，说明这是一块未映射的内存，大概率覆盖的指令跳转地址写错了导致的

         2. 将断点打到调用call 目标函数的反汇编上，重新执行程序，在断点处停止，F11步入函数

         3. 查看函数指令，发现是一条 jmp 4位地址的指令

         4. 查看x64的覆盖代码，用的是x86架构的jmp方式，修改为x64的跳转方式后运行正常

         分析：这个问题为什么不是必现的

         答：x64架构是兼容x86的5字节跳转方式的，但是这种方式只支持±2GB内存地址的跳转，一旦超出，这个地址就是无法预知的地址，如果跳转到了未映射的内存或无法访问的内存，就会出现问题描述中的现象，如果侥幸到了一个映射了且可以访问的地址，那么就会出现无法预知的错误，例如修改了别的内存信息导致行为异常等等。只有当目标函数与HOOK函数偏移量刚好在±2GB以内时，才能正常运行，但在x64架构下，这种概率很低。

         问题2：调试问题1后，成功进入了HOOK函数，在HOOK函数调用跳板函数的地方出现了0x0000018E76DF000A 处有未经处理的异常(在 test_exe.exe 中): 0xC0000005: 读取位置 0xFFFFFFFFFFFFFFFF 时发生访问冲突。  （必现）

         调试过程：

         1. 打断点方式同问题1

         2. 记录跳板函数地址，在反汇编中查看地址内容，地址内容为

```nasm
mov         rax,7FF9CCA232500000h
jmp         rax
```

          3. 查看7FF9CCA232500000h地址内容，发现是????，又是一块未映射的内存，大概率是跳板函数的跳转偏移出错了

          4. 在跳板函数计算偏移位置打断点，重启调试，记录跳板函数地址，查看原函数地址首部指令（此时还未被覆盖），原函数指令信息为

```nasm
jmp         qword ptr [__imp_CreateFileW (07FF9CE1A9890h)]
```

          5.  在内存窗口输入07FF9CE1A9890h，该地址内的值为00007ff9cca24530

          6. 在计算绝对地址代码处打断点，检查一下参数是否存在问题，发现目标函数的传入地址为07FF9CE1A9896h，比看到的原指令的跳转地址多了6h

          7. 查看调用代码，重定向逻辑位置有一个while循环，用于循环解析指令并进行重定向直到长度超过最低覆盖长度（x64至少需要12位指令），在解析指令完之后，传入目标函数地址加上了总指令解析长度，第一个指令长度为6导致多了这个6h，修改为 目标函数地址+总指令解析长度-当前循环解析的指令长度，修改后问题解决