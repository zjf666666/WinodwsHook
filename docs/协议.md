# 协议

| 版本 | 修改人 | 修改时间 | 版本变更内容 |
| --- | --- | --- | --- |
| 0.1.0 | 郑俊峰 | 2025-09-28 | 初始版本，包含基础协议框架 |
|  |  |  |  |

# 一、协议版本号规范

## 1.  格式

`主版本号.次版本号.修订号，如1.2.3`

## 2. 未正式发布阶段（0.Y.Z）

- **格式**：`0.次版本号.修订号`（如 `0.1.0`、`0.2.3`）
- **规则**：
    - 主版本号固定为 `0`，表示处于开发阶段，协议可能频繁变更
    - 次版本号（Y）：当协议有**新增功能**（如新增通用参数、扩展 Hook 类型）时递增
    - 修订号（Z）：当协议仅做**细节优化**（如完善文档描述、修正校验逻辑漏洞）时递增
- **示例**：
    - `0.1.0`：初始版本，包含基础协议框架
    - `0.1.1`：修正文档中的格式错误
    - `0.2.0`：新增 EATHook 类型的专属参数规范

## 3. 正式发布后（X.Y.Z，X ≥ 1）

- **主版本号（X）**：当协议发生**不兼容的重大变更**时递增（如通用参数集重构、HookID 生成算法修改）
- **次版本号（Y）**：当协议有**新增功能但保持向后兼容**时递增（如新增一种 Hook 类型及其参数规范）
- **修订号（Z）**：当协议仅做**向后兼容的问题修复**时递增（如修复参数校验逻辑、完善扩展规则描述）
- **示例**：
    - `1.0.0`：第一个稳定版本，协议内容冻结
    - `1.1.0`：新增 VTableHook 的参数规范（兼容旧版本）
    - `1.1.1`：修复日志格式描述中的歧义
    - `2.0.0`：重构通用参数集（不兼容 1.x 版本）

## 4. 附加规则

- **预发布版本**：可在版本号后加 `beta.1`、`rc.2` 等标识（如 `1.0.0-beta.3`），用于测试阶段
- **版本号递增规则**：某一级别版本号递增时，低级别版本号重置为 0（如 `1.2.3` → 新增功能 → `1.3.0`）
- **文档关联**：每次版本变更必须写明 版本变更内容，记录：
    - 变更内容（新增 / 删除 / 修改的协议条款）
    - 影响范围（如仅 HOOKPARAM 变更，或涉及日志格式和 HookID 算法）
    - 兼容性说明（是否向后兼容，不兼容时的迁移方案）

## 二、HOOKPARAM参数配置

## **1. 总则**

- 目的：规范外部传入 HookEngine 的参数格式，确保参数语义明确、使用一致、扩展可控
- 适用范围：所有通过 HOOKPARAM 结构体与 HookEngine 交互的场景
- 核心原则：**约定优先、代码校验、兼容扩展**

## 2. 参数分类与命名规范

所有参数必须属于以下三类之一，命名格式严格遵循`[命名空间前缀]_[实体]_[属性]`：

| **类别** | **命名空间前缀** | **适用范围** | **示例** |
| --- | --- | --- | --- |
| 通用核心参数 | `common_` | 所有 Hook 类型通用的基础参数 | `common_target_module` |
| 类型专属参数 | `[类型缩写]_`（如`iat_`、`inline_`） | 特定 Hook 类型专用 | `iat_function_name` |
| 扩展参数 | `ext_` | 业务定制化需求，引擎仅透传 | `ext_monitor_log_path` |

**类型缩写约定**：

- IATHook → `iat`
- InlineHook → `inline`
- EATHook → `eat`
- VTableHook → `vtbl`

## 3. 通用核心参数规范（`common_*`）

通用参数为所有 Hook 类型必须支持的基础参数，**不可随意新增**，具体定义如下：

| **参数名** | **数据类型** | **是否必须** | **描述** | **规范化规则** |
| --- | --- | --- | --- | --- |
| `common_architecture` | 字符串 | 是 | 系统架构 | 严格为`x86`/`x64`之一 |
| `common_target_module` | 字符串 | 是 | 目标模块名 | 如`user32.dll`（不区分大小写） |

## **4. 类型专属参数规范**

按 Hook 类型定义专属参数集，**新增 Hook 类型必须同步补充对应参数**：

### 4.1 IAT Hook（`iat_*`）

| **参数名** | **数据类型** | **是否必须** | **描述** | **规范化规则** |
| --- | --- | --- | --- | --- |
| `iat_function_name` | 字符串 | 是 | 目标函数名 | 如`MessageBoxA` |
| `iat_function_address` | 指针 | 是 | hook函数地址 | 通过取函数地址获得，如`&MyMessageBoxA` |

### **4.2 Inline Hook（`inline_*`）**

| **参数名** | **数据类型** | **是否必须** | **描述** | **规范化规则** |
| --- | --- | --- | --- | --- |
| `inline_function_name` | 字符串 | 是 | 目标函数名 | 如`MessageBoxA` |
| `inline_function_address` | 指针 | 是 | hook函数地址 | 通过取函数地址获得，如`&MyMessageBoxA` |

### **4.3 其他类型**

（新增 Hook 类型时在此处补充，格式同上）

## **5. 扩展参数规范（`ext_*`）**

- 命名格式：`ext_[业务域]_[具体含义]`，如`ext_monitor_log_path`
- 业务域需在团队内注册（如`monitor`、`trace`），避免冲突
- 引擎不解析扩展参数，仅负责透传，业务方需自行保证解析一致性
- 禁止使用扩展参数替代已有标准参数（如不得用`ext_target_path`替代`common_target_module`）

## **6. 通用参数升级规则**

当参数满足以下**全部条件**时，可申请从 "类型专属 / 扩展参数" 升级为通用参数：

- **跨类型复用**：至少被 3 种及以上不同 Hook 类型使用，且语义、类型完全一致
- **使用频率**：现有业务中出现频率≥30%（100 个 Hook 配置中至少出现 30 次）
- **抽象性**：语义具备通用性（如`common_timeout_ms`而非`iat_timeout`）
- **无冲突**：与现有通用参数无功能重叠或语义冲突

**升级流程**：

- 提交申请（含使用数据、业务案例）
- 核心团队评审
- 若通过，分配`common_`前缀命名
- 更新元信息表与文档
- 保留原参数名作为过渡期别名（至少 2 个版本周期）

## **7. 校验与兼容机制**

### **7.1 代码化校验**

- 维护参数元信息表（包含名称、类型、校验规则）
- 引擎加载参数时自动校验：必选参数是否缺失、类型是否匹配、格式是否合规
- 示例校验逻辑：

```cpp
// 校验逻辑在HOOK内部进行，HookParam类存储数据均为指针，若出现错误会返回nullptr
// 使用时，直接根据需要内容从HookParam内取数据，若有数据为nullptr，说明错误，如
auto strArch = params.Get<std::string>("common_architecture");
auto hookFunc = params.Get<void*>("iat_function_address");
auto targetFunc = params.Get<std::string>("iat_function_name");
auto targetModule = params.Get<const WCHAR>("common_target_module");
if (!strArch || !hookFunc || !targetFunc || !targetModule)
{
    Logger::GetInstance().Error(L"Get params failed!");
    return false;
}
```

### **7.2 兼容性保障**

- 新增参数默认设为 "可选"，不影响老版本
- 废弃参数需标记`[DEPRECATED]`，并在日志中提示替代方案
- 协议变更时同步升级`algo_version`（与 HookID 生成算法版本联动）

## **8. 维护机制**

- 协议文档与参数元信息表保持同步，代码为唯一可信源
- 任何参数变更需提交评审，通过后更新文档与校验逻辑
- 定期（如每季度）Review 参数使用情况，清理冗余参数

# **三、HookID 生成协议规范（基于规范化文本串接）**

## **1. 总则**

- 目的：规范 HookID 的生成逻辑，确保相同 Hook 操作能生成一致的唯一标识，同时版本兼容与历史追溯能力
- 核心原则：**算法封装、版本可控、字段有序、转义统一**

## **2. 版本控制（algo_version）**

### **2.1 版本定义**

- 格式：`algo_version=N`（N 为非负整数，初始版本为 1）
- 含义：联合版本标识，涵盖 "规范化协议 + 字段集合 + 串接顺序 + 哈希算法" 的组合版本，任一元素变更均需递增版本号
    - 示例：`algo_version=1` 表示 "规范化规则 v1 + SHA-256 哈希算法"

### **2.2 版本管理规则**

- 控制权：`algo_version` 由 HookEngine 内部定义（如通过 `CURRENT_ALGO_VERSION` 常量），外部模块不得传入或修改
- 接口封装：对外仅暴露 `ComputeHookId(HookParam)` 入口函数，不开放版本参数设置，避免外部干预
- 历史兼容：提供引擎内部专用接口（非公共 API），支持指定历史版本复算 HookID，用于回放、迁移或一致性测试
- 持久化格式：
    - 字符串形式：`v{algo_version}:{hash}`（如 `v1:5f4dcc3b5aa765d61d8327deb882cf99`）
    - 结构化存储：需同时保存 `version` 字段与 `hash` 字段，避免版本上下文丢失

### **3. 规范化文本串接规则**

### **3.1 字段组成与顺序**

按以下固定顺序串接字段，使用 `|` 作为分隔符：

`type | caller_module | target_module | symbol | rva | attributes`

各字段定义：

| **字段名** | **含义** | **规范化要求** |
| --- | --- | --- |
| `type` | Hook 类型 | 与 `common_hook_type` 一致（如 `iat`/`inline`/`eat`），严格小写 |
| `caller_module` | 调用者模块 | 统一为小写绝对路径，空值表示全局（用 `""` 占位） |
| `target_module` | 目标模块 | 统一为小写绝对路径，不可为空 |
| `symbol` | 目标符号 | 函数名 / 导出表名（如 `MessageBoxA`），无符号时用 `""` 占位 |
| `rva` | 相对虚拟地址 | 十进制整数（如 `1234`），无偏移时用 `0` 占位 |
| `attributes` | 扩展属性 | 键值对格式（`key1=value1;key2=value2`），无属性时用 `""` 占位 |

### **3.2 转义规则**

- 若字段值中包含 `|`（分隔符）、`=`（键值分隔符）或 `%`（转义符），需使用百分号编码（`%xx`，xx 为 ASCII 十六进制值）
- 转义示例：
    - 原始值 `a|b` → 转义后 `a%7Cb`
    - 原始值 `key=value` → 转义后 `key%3Dvalue`
    - 原始值 `100%` → 转义后 `100%25`
- 规范化阶段必须保证转义逻辑一致，确保相同输入生成相同串接文本

### **4. 哈希计算流程**

1. 提取：从 `HookParam` 中提取对应字段值（如 `common_hook_type` 映射为 `type` 字段）
2. 规范化：按字段规则格式化各值（路径小写、空值占位、数值类型转换等）
3. 转义：对特殊字符执行百分号编码
4. 串接：按固定顺序用 `|` 拼接所有字段，形成原始文本串
5. 哈希：结合 `algo_version` 对应的哈希算法（如 SHA-256），计算文本串的哈希值
6. 生成 ID：按 `v{algo_version}:{hash}` 格式组合为最终 HookID

### **5. 版本变更场景**

当发生以下任一变更时，必须升级 `algo_version`：

- 字段集合变更（新增 / 删除字段，如增加 `flags` 字段）
- 串接顺序调整（如调整为 `type | target_module | caller_module ...`）
- 哈希算法变更（如从 SHA-256 改为 SHA-512）
- 规范化规则修改（如路径格式从相对路径改为绝对路径）

### **6. 兼容性保障**

- 新老版本共存时，通过 `algo_version` 区分 HookID 生成逻辑
- 解析 HookID 时，需先提取版本号，再使用对应版本的规则验证或复算
- 版本升级后，需保留历史版本算法实现，确保旧 HookID 可被正确解析