# 本地进程注入实现说明

## 1. 概述

本地进程注入是 Windows 安全防护系统中的基础功能模块，通过将 DLL 注入到目标进程的内存空间中，实现对目标进程的监控和防护。该模块专注于本地计算机上的进程操作，为系统提供基础的安全监控能力，同时预留了远程注入的扩展接口。

本地进程注入技术主要应用于应用程序行为监控、安全策略执行、恶意行为拦截等场景，能够在不中断目标系统正常运行的情况下，实现安全功能的部署和执行。

## 2. 所属项目与架构位置

### 2.1 所属项目

本地进程注入模块位于 `WindowsSecurityGuard` 项目的 `SecurityCore` 子模块中，作为 HookEngine 的核心组件。

### 2.2 架构位置

在整体系统架构中，本地进程注入模块的位置如下：

```
┌─────────────────────────────────────────────────────────────┐
│                    应用层 (SecurityGuardUI)                  │
├─────────────────────────────────────────────────────────────┤
│                    业务层 (ProtectionModules)                │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐           │
│  │ 本地防护    │ │ 行为监控    │ │ 策略控制    │           │
│  └─────────────┘ └─────────────┘ └─────────────┘           │
├─────────────────────────────────────────────────────────────┤
│                    核心层 (SecurityCore)                     │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐           │
│  │ HookEngine  │ │ProcessInject│ │ 其他核心模块│           │
│  └─────────────┘ └─────────────┘ └─────────────┘           │
├─────────────────────────────────────────────────────────────┤
│                      公共组件层                              │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐           │
│  │   Logger    │ │ EventBus    │ │ ThreadPool  │           │
│  └─────────────┘ └─────────────┘ └─────────────┘           │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐           │
│  │MemoryUtils  │ │ProcessUtils │ │ConfigMgr    │           │
│  └─────────────┘ └─────────────┘ └─────────────┘           │
├─────────────────────────────────────────────────────────────┤
│                     基础工具类层                             │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐           │
│  │StringUtils  │ │ FileUtils   │ │SystemUtils  │           │
│  └─────────────┘ └─────────────┘ └─────────────┘           │
└─────────────────────────────────────────────────────────────┘
```

本地进程注入模块位于核心层的 ProcessInject 子模块，依赖基础工具类层和公共组件层，为业务层提供进程注入服务。

## 3. 设计模式选择

### 3.1 主要设计模式

#### 策略模式 (Strategy Pattern)

**选择原因**：
1. **算法封装**：封装不同的注入技术实现，如CreateRemoteThread、QueueUserAPC等
2. **运行时选择**：根据目标进程环境和安全级别选择最合适的注入策略
3. **消除条件判断**：避免使用大量的条件语句判断不同注入类型
4. **开闭原则**：新增注入技术只需添加新的策略类，无需修改现有代码

**实现方式**：
```cpp
// 注入策略接口
class IInjectionStrategy {
public:
    virtual ~IInjectionStrategy() {}
    virtual bool Inject(DWORD pid, const std::wstring& dllPath) = 0;
    virtual bool Eject(DWORD pid, const std::wstring& dllPath) = 0;
    virtual std::wstring GetStrategyName() const = 0;
};

// 具体策略实现
class CreateRemoteThreadStrategy : public IInjectionStrategy {
public:
    virtual bool Inject(DWORD pid, const std::wstring& dllPath) override;
    virtual bool Eject(DWORD pid, const std::wstring& dllPath) override;
    virtual std::wstring GetStrategyName() const override { return L"CreateRemoteThread"; }
};

class QueueUserAPCStrategy : public IInjectionStrategy {
public:
    virtual bool Inject(DWORD pid, const std::wstring& dllPath) override;
    virtual bool Eject(DWORD pid, const std::wstring& dllPath) override;
    virtual std::wstring GetStrategyName() const override { return L"QueueUserAPC"; }
};
```

#### 工厂模式 (Factory Pattern)

**选择原因**：
1. **创建封装**：封装不同注入策略的创建逻辑
2. **配置驱动**：根据配置创建合适的注入组件

**实现方式**：
工厂模式直接集成在ProcessInjectionManager类中，无需单独抽象InjectionFactory类：
```cpp
class ProcessInjectionManager {
private:
    // 内部实现细节，工厂方法
    IInjectionStrategy* GetStrategy(InjectionMethod method);
    
    // 其他成员...
};
```

### 3.2 扩展接口设计

为了支持未来可能的远程注入功能，我们预留以下扩展接口：

```cpp
// 注入目标接口（可扩展为远程目标）
class IInjectionTarget {
public:
    virtual ~IInjectionTarget() {}
    virtual DWORD GetProcessId() const = 0;
    virtual std::wstring GetProcessName() const = 0;
    virtual bool Is64Bit() const = 0;
    virtual HANDLE OpenProcess(DWORD dwDesiredAccess) const = 0;
};

// 本地注入目标实现
class LocalInjectionTarget : public IInjectionTarget {
private:
    DWORD m_processId;
    std::wstring m_processName;
    bool m_is64Bit;
    
public:
    LocalInjectionTarget(DWORD processId);
    
    virtual DWORD GetProcessId() const override { return m_processId; }
    virtual std::wstring GetProcessName() const override { return m_processName; }
    virtual bool Is64Bit() const override { return m_is64Bit; }
    virtual HANDLE OpenProcess(DWORD dwDesiredAccess) const override;
};
```

## 4. 核心数据结构

### 4.1 注入方法枚举

```cpp
enum class InjectionMethod {
    CreateRemoteThread,    // 使用CreateRemoteThread API
    QueueUserAPC,         // 使用QueueUserAPC API
    SetWindowsHookEx,     // 使用SetWindowsHookEx API
    ThreadHijacking,      // 线程劫持
    ERROR_METHOD          // 用于判断method是否合法
};
```

### 4.2 注入结果结构体

```cpp
struct InjectionResult {
    DWORD ErrorCode;              // 错误代码
    DWORD InjectedModuleBase;     // 注入模块基址
    
    InjectionResult() : ErrorCode(0), InjectedModuleBase(0) {}
};
```

## 5. 核心接口设计

### 5.1 进程注入管理器

```cpp
class ProcessInjectionManager {
public:
    // 单例访问点
    static ProcessInjectionManager& GetInstance();
    
    // 注入操作
    bool InjectDll(DWORD pid, const std::wstring& dllPath, InjectionMethod method = InjectionMethod::CreateRemoteThread);
    bool EjectDll(DWORD pid, const std::wstring& dllPath);
    
    /* 预留接口：远程注入功能待实现 */
    //InjectionResult InjectDll(const IInjectionTarget& target, const std::wstring& dllPath, InjectionMethod method = InjectionMethod::CreateRemoteThread);
    //InjectionResult EjectDll(const IInjectionTarget& target, const std::wstring& dllPath);
    
private:
    // 创建注入策略，内部函数只负责创建和判断逻辑，不对外暴露
    void CreateInjectStrategy(InjectionMethod method);
    
    IInjectionStrategy* GetStrategy(InjectionMethod method);
    
private:
    // 私有构造和析构函数（单例模式）
    ProcessInjectionManager();
    ~ProcessInjectionManager();
    
    // 禁用拷贝构造和赋值操作
    ProcessInjectionManager(const ProcessInjectionManager&) = delete;
    ProcessInjectionManager& operator=(const ProcessInjectionManager&) = delete;
    
private:
    std::vector<std::unique_ptr<IInjectionStrategy>> m_vecInjectionStrategy;
};
```

### 5.2 注入策略选择器

```cpp
class InjectionStrategySelector {
public:
    // 根据目标环境选择最佳注入策略
    static IInjectionStrategy* SelectBestStrategy(const IInjectionTarget& target);
    
    // 检查注入策略是否适用于目标
    static bool IsStrategyApplicable(InjectionMethod method, const IInjectionTarget& target);
    
    // 获取目标支持的所有注入策略
    static std::vector<InjectionMethod> GetSupportedStrategies(const IInjectionTarget& target);
};
```

## 6. 调用方式与流程

### 6.1 基本调用流程

本地进程注入的基本调用流程如下：

1. **获取进程信息**：枚举本地计算机上的进程
2. **选择目标进程**：确定需要注入的目标进程
3. **选择注入方法**：选择适合目标环境的注入方法
4. **执行注入操作**：执行注入操作，将DLL注入到目标进程
5. **处理结果**：处理注入结果，包括成功和失败情况

### 6.2 代码调用示例

```cpp
// 获取进程注入管理器实例
ProcessInjectionManager& injectionManager = ProcessInjectionManager::GetInstance();

// 目标进程ID
DWORD targetProcessId = 1234; // 实际使用时需要获取真实的进程ID

// 执行DLL注入（使用默认的CreateRemoteThread方法）
bool result = injectionManager.InjectDll(
    targetProcessId,
    L"C:\\SecurityGuard\\Hooks\\monitor.dll"
);

// 处理注入结果
if (result) {
    Logger::GetInstance().Info(L"成功注入DLL到进程");
} else {
    Logger::GetInstance().Error(L"注入DLL失败");
}

// 使用不同的注入方法
bool result2 = injectionManager.InjectDll(
    targetProcessId,
    L"C:\\SecurityGuard\\Hooks\\monitor2.dll",
    InjectionMethod::QueueUserAPC
);
```

### 6.3 使用扩展接口的调用示例（预留）

```cpp
// 注：以下代码为预留接口，当前版本尚未实现
/*
// 创建本地注入目标
LocalInjectionTarget target(targetProcessId);

// 使用目标接口执行注入
InjectionResult result = injectionManager.InjectDll(
    target,
    L"C:\\SecurityGuard\\Hooks\\monitor.dll",
    InjectionMethod::CreateRemoteThread
);
*/
```

## 7. 安全性与稳定性考虑

### 7.1 进程权限验证

在执行注入操作前，需要验证当前进程是否具有足够的权限：

```cpp
bool ProcessInjectionManager::HasSufficientPrivileges(DWORD processId) {
    // 尝试以所需权限打开进程
    HANDLE hProcess = OpenProcess(
        PROCESS_CREATE_THREAD | PROCESS_QUERY_INFORMATION | 
        PROCESS_VM_OPERATION | PROCESS_VM_WRITE | PROCESS_VM_READ,
        FALSE,
        processId
    );
    
    if (hProcess == NULL) {
        Logger::GetInstance().Error(StringUtils::FormatString(
            L"无法打开进程 (ID: %d)，错误代码: %d",
            processId,
            GetLastError()
        ));
        return false;
    }
    
    CloseHandle(hProcess);
    return true;
}
```

## 8. 扩展性设计

### 8.1 策略对象池设计

为了支持多种注入方式的同时使用，ProcessInjectionManager类采用策略对象池设计。这种设计有以下几个关键点：

#### 8.1.1 策略对象池实现方案

当前实现采用std::vector存储策略对象，并使用unique_ptr管理对象生命周期：

```cpp
class ProcessInjectionManager {
private:
    // 策略对象池
    std::vector<std::unique_ptr<IInjectionStrategy>> m_vecInjectionStrategy;
};
```

**优点**：
1. **内存布局连续**：std::vector提供连续内存布局，有利于缓存命中率
2. **自动内存管理**：使用unique_ptr自动管理对象生命周期，避免内存泄漏
3. **索引访问**：通过枚举值直接索引访问，实现简单高效
4. **简单直观**：实现简单，易于维护

**缺点**：
1. **空间预分配**：需要预先分配足够的空间，可能存在空闲位置
2. **线程安全**：当前实现未添加互斥锁保护，多线程环境下需要注意

#### 8.1.2 策略对象池管理

当前实现中，策略对象池的管理遵循以下原则：

1. **延迟初始化**：策略对象在首次需要时创建，避免不必要的资源消耗
2. **单例共享**：每种策略类型只创建一个实例，多次使用共享同一实例
3. **自动生命周期管理**：使用unique_ptr自动管理对象生命周期

#### 8.1.3 策略对象池实现示例

```cpp
void ProcessInjectionManager::CreateInjectStrategy(InjectionMethod method)
{
    switch (method) // 使用工厂模式动态创建对象
    {
    case InjectionMethod::CreateRemoteThread:
        m_vecInjectionStrategy[(size_t)method] = std::make_unique<CreateRemoteThreadStrategy>();
        break;
    case InjectionMethod::QueueUserAPC:
        //inject = new QueueUserAPCStrategy();
        break;
    case InjectionMethod::SetWindowsHookEx:
        break;
    case InjectionMethod::ThreadHijacking:
        break;
    default:
        break;
    }
}

// 构造函数中预分配空间
ProcessInjectionManager::ProcessInjectionManager()
{
    // 使用循环赋值的方式填充vector，避免使用resize时，unique_ptr可能的错误操作
    for (size_t i = 0; i < SIZE_INJECTION_METHOD; ++i)
    {
        m_vecInjectionStrategy.emplace_back(nullptr);
    }
}

// 析构函数中无需手动释放资源，unique_ptr会自动管理
ProcessInjectionManager::~ProcessInjectionManager()
{
}
```

### 8.2 单例模式下多种注入方式的支持

虽然ProcessInjectionManager采用单例模式，但它能够同时支持多种注入方式，主要通过以下机制实现：

1. **策略池管理**：在ProcessInjectionManager中维护一个策略对象池（m_vecInjectionStrategy），可以同时存在多种注入策略实例
2. **方法参数化**：InjectDll方法接收InjectionMethod参数，支持动态选择注入方式
3. **延迟创建**：策略对象在首次需要时创建，并缓存以供后续使用
4. **索引访问**：通过枚举值直接索引访问策略对象，实现简单高效

这种设计使得单例模式与多策略支持并不冲突，反而通过集中管理提高了资源利用效率。

### 8.2 远程注入扩展点

本地进程注入模块设计了以下扩展点，以支持未来的远程注入功能：

1. **IInjectionTarget 接口**：通过实现不同的 IInjectionTarget 子类，可以支持本地和远程目标
2. **策略模式**：可以添加专用于远程注入的策略类
3. **内置工厂方法**：可以扩展ProcessInjectionManager的GetStrategy方法以支持远程注入策略的创建

### 8.3 远程注入实现示例（预留）

```cpp
// 远程注入目标实现（预留）
class RemoteInjectionTarget : public IInjectionTarget {
private:
    std::wstring m_hostName;
    DWORD m_processId;
    std::wstring m_processName;
    bool m_is64Bit;
    
public:
    RemoteInjectionTarget(const std::wstring& hostName, DWORD processId);
    
    virtual DWORD GetProcessId() const override { return m_processId; }
    virtual std::wstring GetProcessName() const override { return m_processName; }
    virtual bool Is64Bit() const override { return m_is64Bit; }
    virtual HANDLE OpenProcess(DWORD dwDesiredAccess) const override;
    
    // 远程特有方法
    std::wstring GetHostName() const { return m_hostName; }
};
```

## 9. 总结

本地进程注入模块提供了在本地计算机上向目标进程注入 DLL 的功能，采用策略模式和工厂模式实现了灵活的注入方法选择。通过预留扩展接口，该模块可以在未来扩展为支持远程注入功能，而不需要大幅修改现有代码。

该模块的核心功能包括：

1. 支持多种注入方法（CreateRemoteThread、QueueUserAPC等）
2. 提供进程枚举和信息获取功能
3. 实现了完善的错误处理和日志记录
4. 预留了远程注入的扩展接口

通过这种设计，系统可以先实现本地进程注入的基础功能，再根据需要逐步扩展为支持远程注入的完整功能。