# 本地进程注入实现说明

## 1. 概述

本地进程注入是 Windows 安全防护系统中的基础功能模块，通过将 DLL 注入到目标进程的内存空间中，实现对目标进程的监控和防护。该模块专注于本地计算机上的进程操作，为系统提供基础的安全监控能力，同时预留了远程注入的扩展接口。

本地进程注入技术主要应用于应用程序行为监控、安全策略执行、恶意行为拦截等场景，能够在不中断目标系统正常运行的情况下，实现安全功能的部署和执行。

## 2. 所属项目与架构位置

### 2.1 所属项目

本地进程注入模块位于 `WindowsSecurityGuard` 项目的 `SecurityCore` 子模块中，作为 HookEngine 的核心组件。

### 2.2 架构位置

在整体系统架构中，本地进程注入模块的位置如下：

```
┌─────────────────────────────────────────────────────────────┐
│                    应用层 (SecurityGuardUI)                  │
├─────────────────────────────────────────────────────────────┤
│                    业务层 (ProtectionModules)                │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐           │
│  │ 本地防护    │ │ 行为监控    │ │ 策略控制    │           │
│  └─────────────┘ └─────────────┘ └─────────────┘           │
├─────────────────────────────────────────────────────────────┤
│                    核心层 (SecurityCore)                     │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐           │
│  │ HookEngine  │ │ProcessInject│ │ 其他核心模块│           │
│  └─────────────┘ └─────────────┘ └─────────────┘           │
├─────────────────────────────────────────────────────────────┤
│                      公共组件层                              │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐           │
│  │   Logger    │ │ EventBus    │ │ ThreadPool  │           │
│  └─────────────┘ └─────────────┘ └─────────────┘           │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐           │
│  │MemoryUtils  │ │ProcessUtils │ │ConfigMgr    │           │
│  └─────────────┘ └─────────────┘ └─────────────┘           │
├─────────────────────────────────────────────────────────────┤
│                     基础工具类层                             │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐           │
│  │StringUtils  │ │ FileUtils   │ │SystemUtils  │           │
│  └─────────────┘ └─────────────┘ └─────────────┘           │
└─────────────────────────────────────────────────────────────┘
```

本地进程注入模块位于核心层的 ProcessInject 子模块，依赖基础工具类层和公共组件层，为业务层提供进程注入服务。

## 3. 设计模式选择

### 3.1 主要设计模式

#### 策略模式 (Strategy Pattern)

**选择原因**：
1. **算法封装**：封装不同的注入技术实现，如CreateRemoteThread、QueueUserAPC等
2. **运行时选择**：根据目标进程环境和安全级别选择最合适的注入策略
3. **消除条件判断**：避免使用大量的条件语句判断不同注入类型
4. **开闭原则**：新增注入技术只需添加新的策略类，无需修改现有代码

**实现方式**：
```cpp
// 注入策略接口
class IInjectionStrategy {
public:
    virtual ~IInjectionStrategy() {}
    virtual bool Inject(HANDLE hProcess, const std::wstring& dllPath) = 0;
    virtual bool Eject(HANDLE hProcess, const std::wstring& dllPath) = 0;
    virtual std::wstring GetStrategyName() const = 0;
};

// 具体策略实现
class CreateRemoteThreadStrategy : public IInjectionStrategy {
public:
    virtual bool Inject(HANDLE hProcess, const std::wstring& dllPath) override;
    virtual bool Eject(HANDLE hProcess, const std::wstring& dllPath) override;
    virtual std::wstring GetStrategyName() const override { return L"CreateRemoteThread"; }
};
```

#### 工厂模式 (Factory Pattern)

**选择原因**：
1. **创建封装**：封装不同注入策略的创建逻辑
2. **配置驱动**：根据配置创建合适的注入组件

**实现方式**：
```cpp
class InjectionFactory {
public:
    static IInjectionStrategy* CreateStrategy(InjectionMethod method);
};
```

### 3.2 扩展接口设计

为了支持未来可能的远程注入功能，我们预留以下扩展接口：

```cpp
// 注入目标接口（可扩展为远程目标）
class IInjectionTarget {
public:
    virtual ~IInjectionTarget() {}
    virtual DWORD GetProcessId() const = 0;
    virtual std::wstring GetProcessName() const = 0;
    virtual bool Is64Bit() const = 0;
    virtual HANDLE OpenProcess(DWORD dwDesiredAccess) const = 0;
};

// 本地注入目标实现
class LocalInjectionTarget : public IInjectionTarget {
private:
    DWORD m_processId;
    std::wstring m_processName;
    bool m_is64Bit;
    
public:
    LocalInjectionTarget(DWORD processId);
    
    virtual DWORD GetProcessId() const override { return m_processId; }
    virtual std::wstring GetProcessName() const override { return m_processName; }
    virtual bool Is64Bit() const override { return m_is64Bit; }
    virtual HANDLE OpenProcess(DWORD dwDesiredAccess) const override;
};
```

## 4. 核心数据结构

### 4.1 注入方法枚举

```cpp
enum class InjectionMethod {
    CreateRemoteThread,    // 使用CreateRemoteThread API
    QueueUserAPC,         // 使用QueueUserAPC API
    SetWindowsHookEx,     // 使用SetWindowsHookEx API
    ThreadHijacking       // 线程劫持
};
```

### 4.2 注入结果结构体

```cpp
struct InjectionResult {
    bool Success;                  // 注入是否成功
    std::wstring ErrorMessage;    // 错误信息
    DWORD ErrorCode;              // 错误代码
    DWORD InjectedModuleBase;     // 注入模块基址
    
    InjectionResult() : Success(false), ErrorCode(0), InjectedModuleBase(0) {}
};
```

## 5. 核心接口设计

### 5.1 进程注入管理器

```cpp
class ProcessInjectionManager {
public:
    // 单例访问点
    static ProcessInjectionManager& GetInstance();
    
    // 进程管理
    std::vector<ProcessInfo> EnumProcesses();
    ProcessInfo GetProcessInfo(DWORD processId);
    
    // 注入操作
    InjectionResult InjectDll(DWORD processId, const std::wstring& dllPath, InjectionMethod method = InjectionMethod::CreateRemoteThread);
    InjectionResult InjectDll(const IInjectionTarget& target, const std::wstring& dllPath, InjectionMethod method = InjectionMethod::CreateRemoteThread);
    InjectionResult EjectDll(DWORD processId, const std::wstring& dllPath);
    InjectionResult EjectDll(const IInjectionTarget& target, const std::wstring& dllPath);
    
private:
    // 私有构造和析构函数（单例模式）
    ProcessInjectionManager();
    ~ProcessInjectionManager();
    
    // 禁用拷贝构造和赋值操作
    ProcessInjectionManager(const ProcessInjectionManager&) = delete;
    ProcessInjectionManager& operator=(const ProcessInjectionManager&) = delete;
    
    // 内部实现细节
    IInjectionStrategy* GetStrategy(InjectionMethod method);
};
```

### 5.2 注入策略选择器

```cpp
class InjectionStrategySelector {
public:
    // 根据目标环境选择最佳注入策略
    static IInjectionStrategy* SelectBestStrategy(const IInjectionTarget& target);
    
    // 检查注入策略是否适用于目标
    static bool IsStrategyApplicable(InjectionMethod method, const IInjectionTarget& target);
    
    // 获取目标支持的所有注入策略
    static std::vector<InjectionMethod> GetSupportedStrategies(const IInjectionTarget& target);
};
```

## 6. 调用方式与流程

### 6.1 基本调用流程

本地进程注入的基本调用流程如下：

1. **获取进程信息**：枚举本地计算机上的进程
2. **选择目标进程**：确定需要注入的目标进程
3. **选择注入方法**：选择适合目标环境的注入方法
4. **执行注入操作**：执行注入操作，将DLL注入到目标进程
5. **处理结果**：处理注入结果，包括成功和失败情况

### 6.2 代码调用示例

```cpp
// 获取进程注入管理器实例
ProcessInjectionManager& injectionManager = ProcessInjectionManager::GetInstance();

// 枚举进程
std::vector<ProcessInfo> processes = injectionManager.EnumProcesses();

// 查找目标进程
DWORD targetProcessId = 0;
for (const auto& process : processes) {
    if (process.ProcessName == L"target.exe") {
        targetProcessId = process.ProcessId;
        break;
    }
}

if (targetProcessId == 0) {
    Logger::GetInstance().Error(L"未找到目标进程");
    return;
}

// 执行DLL注入
InjectionResult result = injectionManager.InjectDll(
    targetProcessId,
    L"C:\\SecurityGuard\\Hooks\\monitor.dll",
    InjectionMethod::CreateRemoteThread
);

// 处理注入结果
if (result.Success) {
    Logger::GetInstance().Info(StringUtils::FormatString(
        L"成功注入DLL到进程，模块基址: 0x%08X",
        result.InjectedModuleBase
    ));
} else {
    Logger::GetInstance().Error(StringUtils::FormatString(
        L"注入DLL失败，错误: %s (代码: %d)",
        result.ErrorMessage.c_str(),
        result.ErrorCode
    ));
}
```

### 6.3 使用扩展接口的调用示例

```cpp
// 创建本地注入目标
LocalInjectionTarget target(targetProcessId);

// 使用目标接口执行注入
InjectionResult result = injectionManager.InjectDll(
    target,
    L"C:\\SecurityGuard\\Hooks\\monitor.dll",
    InjectionMethod::CreateRemoteThread
);
```

## 7. 安全性与稳定性考虑

### 7.1 进程权限验证

在执行注入操作前，需要验证当前进程是否具有足够的权限：

```cpp
bool ProcessInjectionManager::HasSufficientPrivileges(DWORD processId) {
    // 尝试以所需权限打开进程
    HANDLE hProcess = OpenProcess(
        PROCESS_CREATE_THREAD | PROCESS_QUERY_INFORMATION | 
        PROCESS_VM_OPERATION | PROCESS_VM_WRITE | PROCESS_VM_READ,
        FALSE,
        processId
    );
    
    if (hProcess == NULL) {
        Logger::GetInstance().Error(StringUtils::FormatString(
            L"无法打开进程 (ID: %d)，错误代码: %d",
            processId,
            GetLastError()
        ));
        return false;
    }
    
    CloseHandle(hProcess);
    return true;
}
```

### 7.2 异常处理

确保注入过程中的异常不会影响系统稳定性：

```cpp
InjectionResult ProcessInjectionManager::InjectDll(DWORD processId, const std::wstring& dllPath, InjectionMethod method) {
    InjectionResult result;
    
    try {
        // 验证DLL文件是否存在
        if (!FileUtils::FileExists(dllPath)) {
            result.ErrorMessage = L"DLL文件不存在";
            result.ErrorCode = ERROR_FILE_NOT_FOUND;
            return result;
        }
        
        // 验证进程权限
        if (!HasSufficientPrivileges(processId)) {
            result.ErrorMessage = L"没有足够的权限操作目标进程";
            result.ErrorCode = ERROR_ACCESS_DENIED;
            return result;
        }
        
        // 获取注入策略
        IInjectionStrategy* strategy = GetStrategy(method);
        if (strategy == nullptr) {
            result.ErrorMessage = L"不支持的注入方法";
            result.ErrorCode = ERROR_NOT_SUPPORTED;
            return result;
        }
        
        // 打开进程
        HANDLE hProcess = OpenProcess(
            PROCESS_CREATE_THREAD | PROCESS_QUERY_INFORMATION | 
            PROCESS_VM_OPERATION | PROCESS_VM_WRITE | PROCESS_VM_READ,
            FALSE,
            processId
        );
        
        if (hProcess == NULL) {
            result.ErrorMessage = L"无法打开目标进程";
            result.ErrorCode = GetLastError();
            return result;
        }
        
        // 执行注入
        bool success = strategy->Inject(hProcess, dllPath);
        
        // 关闭进程句柄
        CloseHandle(hProcess);
        
        if (success) {
            result.Success = true;
            // 获取注入模块基址的代码...
        } else {
            result.ErrorMessage = L"注入操作失败";
            result.ErrorCode = GetLastError();
        }
    }
    catch (const std::exception& ex) {
        result.ErrorMessage = StringUtils::AnsiToWide(ex.what());
        result.ErrorCode = ERROR_UNHANDLED_EXCEPTION;
    }
    catch (...) {
        result.ErrorMessage = L"发生未知异常";
        result.ErrorCode = ERROR_UNHANDLED_EXCEPTION;
    }
    
    return result;
}
```

## 8. 扩展性设计

### 8.1 远程注入扩展点

本地进程注入模块设计了以下扩展点，以支持未来的远程注入功能：

1. **IInjectionTarget 接口**：通过实现不同的 IInjectionTarget 子类，可以支持本地和远程目标
2. **策略模式**：可以添加专用于远程注入的策略类
3. **工厂模式**：可以扩展工厂类以创建远程注入相关的组件

### 8.2 远程注入实现示例（预留）

```cpp
// 远程注入目标实现（预留）
class RemoteInjectionTarget : public IInjectionTarget {
private:
    std::wstring m_hostName;
    DWORD m_processId;
    std::wstring m_processName;
    bool m_is64Bit;
    
public:
    RemoteInjectionTarget(const std::wstring& hostName, DWORD processId);
    
    virtual DWORD GetProcessId() const override { return m_processId; }
    virtual std::wstring GetProcessName() const override { return m_processName; }
    virtual bool Is64Bit() const override { return m_is64Bit; }
    virtual HANDLE OpenProcess(DWORD dwDesiredAccess) const override;
    
    // 远程特有方法
    std::wstring GetHostName() const { return m_hostName; }
};
```

## 9. 总结

本地进程注入模块提供了在本地计算机上向目标进程注入 DLL 的功能，采用策略模式和工厂模式实现了灵活的注入方法选择。通过预留扩展接口，该模块可以在未来扩展为支持远程注入功能，而不需要大幅修改现有代码。

该模块的核心功能包括：

1. 支持多种注入方法（CreateRemoteThread、QueueUserAPC等）
2. 提供进程枚举和信息获取功能
3. 实现了完善的错误处理和日志记录
4. 预留了远程注入的扩展接口

通过这种设计，系统可以先实现本地进程注入的基础功能，再根据需要逐步扩展为支持远程注入的完整功能。