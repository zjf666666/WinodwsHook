#pragma once

#include "InstructionTypes.h"

// 前向声明：不透明结构体，隐藏内部实现
typedef struct ZydisContext* ZydisContextPtr;

/*
 * zydis库封装类：封装zydis各种操作实现指令解析、重定向功能
 * 这个类没写好，这个类其实是有状态的，正常应该是使用实例化工具类
 * 将ZydisContextPtr作为一个私有成员，传入架构（架构应该是要传的，
 * 根据函数地址应该没办法判断架构）及函数地址，自动解析指令，调用
 * 重定向函数后，根据存放在ZydisContextPtr的解析结果处理
 * 这样可以更好的隐藏实现细节，外部也不再需要关心ZydisContext状态
 */
class ZydisUtils
{
public:
    static ZydisContextPtr CreateContext(bool is64Bit);

    static void DestroyContext(ZydisContextPtr context);

    /*
     * @brief 使用Zydis库解析x86/x64指令，提取指令长度、类型和重定位信息
     * @param [IN] instructionBytes 指向待解析指令字节序列的指针，不能为空
     *        [IN] length 解析长度
     *        [OUT] parseLength 实际指令长度
     *        [OUT] zyContext 存储解析结果的结构体指针
     * @return 解析成功返回true，失败返回false（如指令无效、参数错误等）
     */
    static bool ParseInstruction(
        const void* instructionBytes,
        size_t length,
        size_t* parseLength,  // 实际解析长度
        ZydisContextPtr zyContext // !!!请注意，该参数在外部是不可读的
    );

    /**
     * @brief 重定位指令，根据指令类型将源地址的指令重定位到目标地址
     *
     * @param [IN] instruction   指令信息结构体
     *        [IN] sourceAddress 指令的原始地址
     *        [IN] targetAddress 指令将被重定位到的目标地址
     *        [IN] bufferSize    输出缓冲区的大小
     *        [OUT] outputSize   实际写入输出缓冲区的字节数
     * @return 重定位成功返回true，失败返回false
     */
    static bool RelocateInstruction(
        ZydisContextPtr zyData,
        BYTE* sourceAddress,
        BYTE* targetAddress,
        size_t* bufferSize,
        size_t* outputSize
    );

    static bool IsNeedFrontTrampoline(ZydisContextPtr zyData);

    static bool GenerateFrontTrampoline(
        ZydisContextPtr zyData,
        BYTE* sourceAddress,
        BYTE* targetAddress,
        size_t* bufferSize,
        size_t* outputSize
    );

private:
    // 获取指令类型
    static InstructionType GetInstructionType(const ZydisContextPtr zyData);

    // 获取是否是相对寻址
    static bool IsRelativeInstruction(const ZydisContextPtr zyData);

    // 是否存在RIP寻址
    static bool IsRipInstruction(const ZydisContextPtr zyContext);

    // 重定向近跳转指令
    static bool RelocateRelativeJump(
        ZydisContextPtr zyData, // 指令解析结果
        BYTE* sourceAddress,    // 原始指令地址
        BYTE* targetAddress,    // 修改后指令保存地址
        size_t* bufferSize,      // 输出缓冲区大小
        size_t* outputSize      // 实际写入大小
    );

    // 重定向远跳转（绝对地址）指令，通常转换为间接跳转
    static bool RelocateAbsoluteJump();

    // 重定向间接跳转指令
    static bool RelocateIndirectJump();

    // 重定向条件跳转指令
    static bool RelocateConditionalJump();

    // 重定向近调用指令
    static bool RelocateRelativeCall();

    // 重定向远调用（绝对地址）指令，通常转换为间接调用
    static bool RelocateAbsoluteCall();

    // 无需重定向，直接拷贝
    static bool CopyInstruction(
        ZydisContextPtr zyData,
        BYTE* sourceAddress,
        BYTE* targetAddress,
        size_t* bufferSize,
        size_t* outputSize
    );

    // 检测RelativeJump参数是否合法
    static bool CheckRelativeJumpParam(
        BYTE* targetAddress,    // 修改后指令保存地址
        size_t* bufferSize,      // 输出缓冲区大小
        size_t needSize         // 需要的大小
    );

    // 检测RelativeJump参数是否合法
    static UINT_PTR CalculateRIPAbsoluteAddr(
        ZydisContextPtr zyData, // 指令解析结果
        BYTE* sourceAddress    // 原始指令地址
    );

    // 计算间接寻址地址
    static UINT64 CalculateIndirectJumpTarget(
        ZydisContextPtr zyData, // 指令解析结果
        BYTE* sourceAddress    // 原始指令地址
    );

    // ptr读取地址  len读取长度  output输出内容
    static bool ReadMemory(UINT_PTR ptr, UINT len, UINT64& output);

private:
    //static thread_local uint64_t tlsIndirectTarget; // tls保证线程安全

private:
    /*
     * 以下代码为规范性代码，静态工具类应避免显式生成对象，使用::的形式进行调用
     * 删除拷贝构造函数及拷贝赋值函数避免友元函数或成员函数进行拷贝操作
     */
    ZydisUtils() {} // 私有构造函数，防止外部调用构造
    ~ZydisUtils() {} // 私有析构函数，防止外部调用析构
    ZydisUtils(const ZydisUtils&) = delete; // 删除拷贝构造函数
    ZydisUtils& operator=(const ZydisUtils&) = delete; // 删除拷贝赋值操作
};

